diff -Ncr new_p/ns-allinone-2.27/ns-2.27/Makefile.in pdns-ia64/ns-allinone-2.27/ns-2.27/Makefile.in
*** new_p/ns-allinone-2.27/ns-2.27/Makefile.in	Wed Jan 28 20:50:08 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/Makefile.in	Mon Feb  2 18:01:28 2004
***************
*** 30,35 ****
--- 30,38 ----
  # Pathname of directory to install the man page
  MANDEST	= @prefix@/man
  
+ # ALFRED reduce console output on compile
+ .SILENT:
+ 
  BLANK	= # make a blank space.  DO NOT add anything to this line
  
  # The following will be redefined under Windows (see WIN32 lable below)
***************
*** 57,65 ****
  LDFLAGS	= $(STATIC)
  LDOUT	= -o $(BLANK)
  
! DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
  
! INCLUDES = \
  	-I. @V_INCLUDE_X11@ \
  	@V_INCLUDES@ \
  	-I./tcp -I./sctp -I./common -I./link -I./queue \
--- 60,74 ----
  LDFLAGS	= $(STATIC)
  LDOUT	= -o $(BLANK)
  
! # ALFRED libSynk defines
! KITHOME = $(HOME)/libsynk
! KITLIBS = -L$(KITHOME)/fdkcompat -lbrti -L$(KITHOME) -lsynk
! 
! # ALFRED add NIXVECTOR and USE_COMPRESSION
! DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test -DNIXVECTOR -DUSE_COMPRESSION
  
! # ALFRED rename INCLUDES to BASEINCLUDES
! BASEINCLUDES = \
  	-I. @V_INCLUDE_X11@ \
  	@V_INCLUDES@ \
  	-I./tcp -I./sctp -I./common -I./link -I./queue \
***************
*** 69,74 ****
--- 78,96 ----
  	-I./diffusion3/lib/nr -I./diffusion3/ns \
  	-I./diffusion3/filter_core -I./asim/ -I./qs
  
+ # ALFRED define includes for RTIKIT
+ #BPDEF = -DUSE_BACKPLANE
+ BPOBJS = \
+ 	backplane/dsim.o \
+ 	backplane/dsimtcp.o \
+ 	backplane/dsimip.o \
+ 	backplane/dsimcmn.o \
+ 	backplane/hdr_baggage.o
+ 	# backplane/cq.o
+ 
+ # ALFRED libSynk includes
+ KITINCL = $(BPDEF) -I$(KITHOME)/fdkcompat -I$(KITHOME) -I.
+ INCLUDES = $(BASEINCLUDES) $(KITINCL)
  
  LIB	= \
  	@V_LIBS@ \
***************
*** 77,82 ****
--- 99,107 ----
  	-lm @LIBS@
  #	-L@libdir@ \
  
+ # ALFRED define libs for libSynk-TCP; add -lgm below if you have Myrinet
+ LIBT = $(LIB) $(KITLIBS) -lm -ldl
+ 
  CFLAGS	= $(CCOPT) $(DEFINE)
  
  # Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
***************
*** 86,95 ****
--- 111,122 ----
  
  .cc.o:
  	@rm -f $@
+ 	@echo Compiling $*.cc
  	$(CPP) -c $(CFLAGS) $(INCLUDES) -o $@ $*.cc
  
  .c.o:
  	@rm -f $@
+ 	@echo Compiling $*.c
  	$(CC) -c $(CFLAGS) $(INCLUDES) -o $@ $*.c
  
  
***************
*** 98,103 ****
--- 125,132 ----
  NS	= ns
  NSX	= nsx
  NSE	= nse
+ # ALFRED add pdns target
+ PDNS = pdns
  
  # To allow conf/makefile.win overwrite this macro
  # We will set these two macros to empty in conf/makefile.win since VC6.0
***************
*** 309,314 ****
--- 338,348 ----
  OBJ_COMPAT = $(OBJ_GETOPT) common/win32.o
  #XXX compat/win32x.o compat/tkConsole.o
  
+ # ALFRED add dummy CC
+ OBJ_DUMMY_CC = \
+ 	rti/rtidummy.o \
+ 	rti/hdr_rti.o
+ 
  OBJ_EMULATE_CC = \
  	emulate/net-ip.o \
  	emulate/net.o \
***************
*** 326,331 ****
--- 360,375 ----
  OBJ_EMULATE_C = \
  	emulate/inet.o
  
+ # ALFRED additions for PDNS
+ OBJ_DIST = \
+ 	rti/rtisched.o \
+ 	rti/rtirouter.o \
+ 	rti/rtilink.o \
+ 	rti/rticompress.o \
+ 	rti/hdr_rti.o \
+ 	tcp/tcp-listener.o \
+ 	classifier/delayfilter.o
+ 
  OBJ_GEN = $(GEN_DIR)version.o $(GEN_DIR)ns_tcl.o $(GEN_DIR)ptypes.o
  
  SRC =	$(OBJ_C:.o=.c) $(OBJ_CC:.o=.cc) \
***************
*** 334,343 ****
  
  OBJ =	$(OBJ_C) $(OBJ_CC) $(OBJ_GEN) $(OBJ_COMPAT)
  
  CLEANFILES = ns nse nsx ns.dyn $(OBJ) $(OBJ_EMULATE_CC) \
  	$(OBJ_EMULATE_C) common/tclAppInit.o \
  	$(GEN_DIR)* $(NS).core core core.$(NS) core.$(NSX) core.$(NSE) \
! 	common/ptypes2tcl common/ptypes2tcl.o 
  
  SUBDIRS=\
  	indep-utils/cmu-scen-gen/setdest \
--- 378,389 ----
  
  OBJ =	$(OBJ_C) $(OBJ_CC) $(OBJ_GEN) $(OBJ_COMPAT)
  
+ # ALFRED add PDNS object files
  CLEANFILES = ns nse nsx ns.dyn $(OBJ) $(OBJ_EMULATE_CC) \
  	$(OBJ_EMULATE_C) common/tclAppInit.o \
  	$(GEN_DIR)* $(NS).core core core.$(NS) core.$(NSX) core.$(NSE) \
! 	common/ptypes2tcl common/ptypes2tcl.o $(PDNS) rti/*.o tcp/tcp-listener.o \
! 	classifier/delayfilter.o
  
  SUBDIRS=\
  	indep-utils/cmu-scen-gen/setdest \
***************
*** 348,362 ****
  
  BUILD_NSE = @build_nse@
  
! all: $(NS) $(BUILD_NSE) all-recursive
! 
  
  all-recursive:
  	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) all; ) done
  
! $(NS): $(OBJ) common/tclAppInit.o Makefile
  	$(LINK) $(LDFLAGS) $(LDOUT)$@ \
! 		common/tclAppInit.o $(OBJ) $(LIB)
  
  Makefile: Makefile.in
  	@echo "Makefile.in is newer than Makefile."
--- 394,416 ----
  
  BUILD_NSE = @build_nse@
  
! # ALFRED modify all target to include PDNS
! all: $(NS) $(PDNS)
! #all: $(NS) $(BUILD_NSE) all-recursive
  
  all-recursive:
  	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) all; ) done
  
! # ALFRED modify ns target to include dummy CC
! $(NS): $(OBJ) $(OBJ_DUMMY_CC) common/tclAppInit.o Makefile
  	$(LINK) $(LDFLAGS) $(LDOUT)$@ \
! 		common/tclAppInit.o $(OBJ) $(OBJ_DUMMY_CC) $(LIB)
! 
! # ALFRED add PDNS target
! $(PDNS): $(OBJ) common/tclAppInit.o Makefile $(OBJ_DIST)
! 	@echo Linking pdns
! 	$(LINK) $(LDFLAGS) $(LDOUT)$@ \
! 		common/tclAppInit.o $(OBJ) $(OBJ_DIST) $(LIBT)
  
  Makefile: Makefile.in
  	@echo "Makefile.in is newer than Makefile."
***************
*** 451,457 ****
--- 505,518 ----
  	tcl/lib/ns-srcrt.tcl \
  	tcl/mcast/ns-lms.tcl \
  	tcl/lib/ns-qsnode.tcl \
+ 	tcl/lib/gt-rtilib.tcl \
+ 	tcl/rti/ns-rtiagent.tcl \
+ 	tcl/rti/ns-rtilink.tcl \
+ 	tcl/rti/ns-rtinode.tcl \
+ 	tcl/rti/ns-rtisim.tcl \
+ 	tcl/rti/ns-rti-default.tcl \
  	@V_NS_TCL_LIB_STL@
+ # ALFRED add above dependencies in tcl/rti* and tcl/lib/gt-*
  
  $(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
  	$(TCLSH) bin/tcl-expand.tcl tcl/lib/ns-lib.tcl @V_NS_TCL_LIB_STL@ | $(TCL2C) et_ns_lib > $@
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/apps/app.cc pdns-ia64/ns-allinone-2.27/ns-2.27/apps/app.cc
*** new_p/ns-allinone-2.27/ns-2.27/apps/app.cc	Wed Jan 28 20:50:00 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/apps/app.cc	Sat Jan 31 14:52:20 2004
***************
*** 76,81 ****
--- 76,90 ----
  			tcl.resultf("%s", agent_->name());
  			return (TCL_OK);
  		}
+     // New commands by GFR...more generic recv enabling
+     if (strcmp(argv[1], "enable-recv") == 0) {
+       enableRecv_ = 1;
+       return (TCL_OK);
+     }
+     if (strcmp(argv[1], "enable-resume") == 0) {
+       enableResume_ = 1;
+       return (TCL_OK);
+     }
  	}
  	else if (argc == 3) {
  		if (strcmp(argv[1], "attach-agent") == 0) {
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/apps/udp.cc pdns-ia64/ns-allinone-2.27/ns-2.27/apps/udp.cc
*** new_p/ns-allinone-2.27/ns-2.27/apps/udp.cc	Wed Jan 28 20:50:00 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/apps/udp.cc	Sat Jan 31 14:52:19 2004
***************
*** 106,111 ****
--- 106,112 ----
  	if (app_ ) {
  		// If an application is attached, pass the data to the app
  		hdr_cmn* h = hdr_cmn::access(pkt);
+     if(1)recvBytes(h->size());else//KALYAN
  		app_->process_data(h->size(), pkt->userdata());
  	} else if (pkt->userdata() && pkt->userdata()->type() == PACKET_DATA) {
  		// otherwise if it's just PacketData, pass it to Tcl
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/classifier/delayfilter.cc pdns-ia64/ns-allinone-2.27/ns-2.27/classifier/delayfilter.cc
*** new_p/ns-allinone-2.27/ns-2.27/classifier/delayfilter.cc	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/classifier/delayfilter.cc	Sat Jan 31 14:52:23 2004
***************
*** 0 ****
--- 1,126 ----
+ //Fontas Dimitropoulos GaTech  Spring 2003 
+ //Simple filter that adds some delay
+ 
+ #include "delayfilter.h"
+ #include "packet.h"
+ 
+ 
+ static class DelayMultiFieldFilterClass : public TclClass {
+ public:
+ 	DelayMultiFieldFilterClass() : TclClass("Filter/MultiField/DelayMultiField") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new DelayMultiFieldFilter);
+ 	}
+ } class_delay_filter_multifield;
+ 
+ void DelayMultiFieldFilter::recv(Packet* p, Handler* h)
+ {
+ 	Scheduler& s = Scheduler::instance();
+   
+   switch(filter(p)) {
+ 	case DROP : 
+ 	  if (h) h->handle(p);
+ 	  drop(p);
+ 	  break;
+ 	case DUPLIC :
+ 	  if (filter_target_)
+ 	    filter_target_->recv(p->copy(), h);
+ 	  /* fallthrough */
+ // 	case PASS :
+ // 	  if(debug_)printf("D(%s)\n",name());	  
+ // 	  send(p, h);
+ // 	  break;
+         case PASS :
+ 	  if(debug_) printf("P(%s)\n",name());	  
+ 	  if(disable_) send(p, h);
+ 	  else {
+ 	    Scheduler& s = Scheduler::instance();
+ 	    s.schedule(this, p, delay_);
+ 	  }
+ 	  break;
+ 	case FILTER :
+ 	  if(debug_) printf("D(%s)\n",name());
+ 	  filter_target_->recv((Packet*)p, (Handler*) NULL);
+ 	  break;
+   } 
+ }
+ 
+ 
+ void DelayMultiFieldFilter::handle(Event* e)
+ {
+ //filter_target_->recv((Packet*)e, (Handler*) NULL);
+   send((Packet*)e, (Handler*)NULL);
+ }
+ 
+ MultiFieldFilter::filter_e DelayMultiFieldFilter::filter(Packet *p) 
+ {
+   fieldobj* tmpfield;
+   
+   if(disable_) return (PASS);
+   
+   tmpfield = field_list_;
+   if(and_rules_) { 
+     while (tmpfield != 0) {
+       if (*(int *)p->access(tmpfield->offset) == tmpfield->match)
+ 	tmpfield = tmpfield->next;
+       else 
+ 	return (FILTER);
+     }
+     return(PASS);
+   } else { 
+     while (tmpfield != 0) {
+       if (*(int *)p->access(tmpfield->offset) == tmpfield->match)
+ 	return (PASS);
+       else 
+ 	tmpfield =tmpfield->next;
+     }
+     return(FILTER);
+   }
+ }
+ 
+ int DelayMultiFieldFilter::command(int argc, const char*const* argv)
+ {
+  	Tcl& tcl = Tcl::instance();
+ 	if (argc == 2) {
+ 	  if (strcmp(argv[1], "debug") == 0) {
+ 	    debug_ = true;
+ 	    return TCL_OK;
+ 	  }
+ 	}
+ 
+  	if (argc == 3) {
+  		if (strcmp(argv[1], "filter-delay") == 0) {
+  		        delay_ = atof(argv[2]);
+  			return TCL_OK;
+  		}
+ 	}
+ 	if (argc == 2){
+ 	  if (strcmp(argv[1], "on") == 0) {
+ 	    if (!disable_) 
+ 	      if(debug_)printf("Warning, attempt to enable filter(%s) while enabled\n",name());
+ 	    else {
+ 	      if(debug_)printf("Turning filter(%s) on\n",name());
+ 	    }
+ 	    disable_ = false;		      
+ 	    return TCL_OK;
+ 	  }
+ 	  if (strcmp(argv[1], "off") == 0) {
+ 	    if (disable_) 
+ 	      if(debug_) printf("Warning, attempt to disable filter(%s) while disabled\n",name());
+ 	    else { 
+ 	      if(debug_) printf("Turning filter(%s) off\n",name());
+ 	    }
+ 	    disable_ = true;
+ 	    return TCL_OK;
+ 	  }
+ 	  if (strcmp(argv[1], "or-rules") == 0) {
+ 	    if (!and_rules_) 
+ 	      if(debug_) printf("Warning, using OR filter\n");
+ 
+ 	    and_rules_ =false;
+ 	    return TCL_OK;
+ 	  }
+ 	  
+  	}
+  	return MultiFieldFilter::command(argc, argv);
+ }
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/classifier/delayfilter.h pdns-ia64/ns-allinone-2.27/ns-2.27/classifier/delayfilter.h
*** new_p/ns-allinone-2.27/ns-2.27/classifier/delayfilter.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/classifier/delayfilter.h	Sat Jan 31 14:52:23 2004
***************
*** 0 ****
--- 1,25 ----
+ // Fontas Dimitropoulos GaTech Spring 2003
+ 
+ 
+ #ifndef ns_dfilter_h
+ #define ns_dfilter_h
+ 
+ #include "filter.h"
+ 
+ 
+ class DelayMultiFieldFilter : public MultiFieldFilter {
+  public:
+   DelayMultiFieldFilter():delay_(0),
+     disable_(false),and_rules_(true),debug_(false){}; 
+ protected:
+ 	int command(int argc, const char* const* argv);
+ 	void recv(Packet*, Handler* h= 0);
+ 	void handle (Event* e);
+ 	filter_e filter(Packet *p);
+ 	double delay_;
+ 	bool disable_;
+ 	bool and_rules_; // if false rules are ORed,otherwise ANDed
+ 	int debug_;
+ };
+ 
+ #endif /* ns_dfilter_h */
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/common/agent.cc pdns-ia64/ns-allinone-2.27/ns-2.27/common/agent.cc
*** new_p/ns-allinone-2.27/ns-2.27/common/agent.cc	Wed Jan 28 20:50:01 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/common/agent.cc	Sat Jan 31 14:52:23 2004
***************
*** 86,91 ****
--- 86,97 ----
  	delay_bind_init_one("flags_");
  	delay_bind_init_one("ttl_");
  	delay_bind_init_one("class_");
+   // GFR Additions for pdns
+   delay_bind_init_one("dst_ipaddr_");
+   delay_bind_init_one("dst_ipport_");
+   delay_bind_init_one("my_ipaddr_");
+   delay_bind_init_one("my_port_");
+   // End GFR Additions
  	Connector::delay_bind_init_all();
  }
  
***************
*** 101,106 ****
--- 107,118 ----
  	if (delay_bind(varName, localName, "flags_", (int*)&flags_, tracer)) return TCL_OK;
  	if (delay_bind(varName, localName, "ttl_", &defttl_, tracer)) return TCL_OK;
  	if (delay_bind(varName, localName, "class_", (int*)&fid_, tracer)) return TCL_OK;
+   // GFR Additions for pdns
+   if (delay_bind(varName, localName, "dst_ipaddr_", (int*)&dst_ipaddr_, tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "dst_ipport_", (int*)&dst_ipport_, tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "my_ipaddr_", (int*)&my_ipaddr_, tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "my_port_", (int*)&my_port_, tracer)) return TCL_OK;
+   // End GFR Additions
  	return Connector::delay_bind_dispatch(varName, localName, tracer);
  }
  
***************
*** 479,484 ****
--- 491,504 ----
  	iph->prio() = prio_;
  	iph->ttl() = defttl_;
  
+   // GFR Modifications for pdns
+   hdr_rti* rtih = hdr_rti::access(p);
+   rtih->ipdst() = dst_ipaddr_;
+   rtih->ipdstport() = dst_ipport_;
+   rtih->ipsrc() = my_ipaddr_;
+   rtih->ipsrcport() = my_port_;
+   // End GFR Additions
+ 
  	hdr_flags* hf = hdr_flags::access(p);
  	hf->ecn_capable_ = 0;
  	hf->ecn_ = 0;
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/common/agent.h pdns-ia64/ns-allinone-2.27/ns-2.27/common/agent.h
*** new_p/ns-allinone-2.27/ns-2.27/common/agent.h	Wed Jan 28 20:50:01 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/common/agent.h	Sat Jan 31 14:52:23 2004
***************
*** 42,47 ****
--- 42,51 ----
  #include "timer-handler.h"
  #include "ns-process.h"
  #include "app.h"
+ // GFR Addition for pdns
+ #include "rti/hdr_rti.h"
+ // End GFR Addition
+ 
  //#include "basetrace.h"
  #define TIME_FORMAT "%.15g"
  // TIME_FORMAT is in basetrace.h, but including that header leads to problems
***************
*** 102,107 ****
--- 106,113 ----
  	inline nsaddr_t& dport() { return dst_.port_; }
  	void set_pkttype(packet_t pkttype) { type_ = pkttype; }
  	inline packet_t get_pkttype() { return type_; }
+   // ALFRED add ipaddr accessor
+   ipaddr_t get_ipaddr() { return my_ipaddr_; }
  
   protected:
  	int command(int argc, const char*const* argv);
***************
*** 136,141 ****
--- 142,154 ----
  
  	Application *app_;		// ptr to application for callback
  
+   // GFR Additions for pdns
+   ipaddr_t     dst_ipaddr_; /* Used for remote connections */
+   ipportaddr_t dst_ipport_; /* Used for remote connections */
+   ipaddr_t     my_ipaddr_;  /* IPAddress of attached node */
+   ipportaddr_t my_port_;    /* Port I am bound to */
+   // End GFR Additions
+ 
  	virtual void trace(TracedVar *v);
  	void deleteAgentTrace();
  	void addAgentTrace(const char *name);
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/common/pktcount.h pdns-ia64/ns-allinone-2.27/ns-2.27/common/pktcount.h
*** new_p/ns-allinone-2.27/ns-2.27/common/pktcount.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/common/pktcount.h	Sat Jan 31 14:52:23 2004
***************
*** 0 ****
--- 1,16 ----
+ #ifndef pktcount_h
+ #define pktcount_h
+ #endif
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ extern unsigned long long pktC;
+ extern unsigned long long dropPkts;
+ extern unsigned long long rlinkPktC;
+ 
+ #ifdef __cplusplus
+ }
+ #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/common/scheduler-map.cc pdns-ia64/ns-allinone-2.27/ns-2.27/common/scheduler-map.cc
*** new_p/ns-allinone-2.27/ns-2.27/common/scheduler-map.cc	Wed Jan 28 20:50:01 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/common/scheduler-map.cc	Sat Jan 31 14:52:23 2004
***************
*** 1,4 ****
! /* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
  /*
   * Copyright (c) 1994 Regents of the University of California.
   * All rights reserved.
--- 1,4 ----
! /* -*-	Mode:C++; c-basic-offset:2; tab-width:2; indent-tabs-mode:t -*- */
  /*
   * Copyright (c) 1994 Regents of the University of California.
   * All rights reserved.
***************
*** 33,71 ****
   *
   */
  
! #include "config.h"
! #ifdef HAVE_STL
! 
! // Event Scheduler using the standard library std::set
  // Contributed by George F. Riley, Georgia Tech.  Spring 2002
  
  #include <stdio.h>
- #include <set>
- 
- #include "scheduler.h"
  
! 
! class MapScheduler : public Scheduler {
! public:
! 	MapScheduler();
! 	~MapScheduler();
! public:
! 	void cancel(Event*);
! 	void insert(Event*);
! 	Event* lookup(scheduler_uid_t uid);
! 	Event* deque();
! 	const Event *head() { return *EventQueue_.begin(); }
! private:
! 	struct event_less_adapter {
! 		bool operator()(const Event *e1, const Event *e2) const
! 		{
! 			return e1->time_ < e2->time_ ||
! 				(e1->time_ == e2->time_	&& e1->uid_ < e2->uid_); // for FIFO
! 		}
! 	};
! 	typedef set<Event *, event_less_adapter> EventQueue_t;
! 	EventQueue_t EventQueue_;	// The actual event list
! };
  
  static class MapSchedulerClass : public TclClass {
  public:
--- 33,45 ----
   *
   */
  
! // Event Scheduler using the Standard Template Library map and deque
  // Contributed by George F. Riley, Georgia Tech.  Spring 2002
+ // Modified by Alfred Park for compatibility with ns-2.26
  
  #include <stdio.h>
  
! #include "scheduler-map.h"
  
  static class MapSchedulerClass : public TclClass {
  public:
***************
*** 76,123 ****
  } class_stl_sched;
  
  MapScheduler::MapScheduler()
  {
  }
  
  MapScheduler::~MapScheduler()
  {
  }
  
  void MapScheduler::cancel(Event* p)
  {
! 	EventQueue_t::iterator eIT = EventQueue_.find(p);
! 	if (eIT != EventQueue_.end()) {
! 		EventQueue_.erase(eIT);
! 		p->uid_ = -p->uid_; // Negate the uid for reuse
! 	}
  }
  
  void MapScheduler::insert(Event* p)
  {
! 	EventQueue_.insert(p);
  }
  
  Event* MapScheduler::lookup(scheduler_uid_t uid) // look for event
  {
! 	for (EventQueue_t::iterator eIT = EventQueue_.begin();
! 	     eIT != EventQueue_.end(); 
! 	     ++eIT) {
! 		if ((*eIT)->uid_ == uid) 
! 			return (*eIT);
! 	}
! 
! 	return 0;
  }
  
! Event* MapScheduler::deque()
  {
! 	EventQueue_t::const_iterator eIT = EventQueue_.begin();
! 	if (eIT == EventQueue_.end()) 
! 		return 0;
! 
! 	EventQueue_.erase(eIT);
! 
! 	return *eIT;
  }
  
- #endif // HAVE_STL
--- 50,224 ----
  } class_stl_sched;
  
  MapScheduler::MapScheduler()
+   : fuid(1), luid(1), totev(0), totrm(0), verbose(false), verbosemod(1000)
  {
+ 	hint = EventList.end();
  }
  
  MapScheduler::~MapScheduler()
  {
  }
  
+ int MapScheduler::command(int argc, const char*const* argv)
+ {
+ 	if (argc == 2)
+ 		{
+ 			if (strcmp(argv[1], "verbose") == 0)
+ 				{
+ 					verbose = true;
+ 					return (TCL_OK);
+ 				}
+ 		}
+ 	if (argc == 3)
+ 		{
+ 			if (strcmp(argv[1], "verbose") == 0)
+ 				{
+ 					verbose = true;
+ 					verbosemod = atol(argv[2]);
+ 					return (TCL_OK);
+ 				}
+ 		}
+ 	return Scheduler::command(argc, argv);
+ }
+ 
  void MapScheduler::cancel(Event* p)
  {
!   EventMap_t::iterator i = EventList.find(KeyPair_t(p->time_, p->uid_));
!   if (i != EventList.end())
!     {
!       EventList.erase(i);
! 			hint = EventList.end(); 
!       totrm++;
! #ifdef USING_UIDDEQ
!       // Null out the UIDDeq entry
!       if (p->uid_ >= fuid && p->uid_ < luid)
! 				{
! 					UIDDeq[p->uid_ - fuid] = NULL;
! 				}
! #endif
! 			p->uid_ = -p->uid_; // Negate the uid for reuse
!     }
  }
  
  void MapScheduler::insert(Event* p)
  {
! #if 0 //KALYAN
!   hint = EventList.insert( hint, EventMap_t::value_type(KeyPair_t(p->time_, p->uid_), p));
! #else //KALYAN
!   hint = EventList.insert( EventMap_t::value_type(KeyPair_t(p->time_, p->uid_), p)).first;
! #endif //KALYAN
! #ifdef USING_UIDDEQ
!   // And manage the UID Deq
!   if (p->uid_ != luid)
!     {
!       printf("HuH?  MapScheduler::insert uid mismatch ");
! 			printf(UID_PRINTF_FORMAT, p->uid_);
! 			printf(" ");
! 			printf(UID_PRINTF_FORMAT, luid);
! 			printf("\n");
!     }
!   UIDDeq.push_back(p);
! #endif
! 	luid++;
! 	totev++;
! 	if (verbose && ((totev % verbosemod) == 0))
! 		{
! 			printf("STLSched :total of %ld events, current size %ld\n",
! 						 totev, totev - totrm);
! 		}
  }
  
  Event* MapScheduler::lookup(scheduler_uid_t uid) // look for event
  {
! #ifdef USING_UIDDEQ
!   if (uid >= fuid && uid < luid) return UIDDeq[uid-fuid];
!   printf("HuH?  MapScheduler::lookup, uid out of range ");
! 	printf(UID_PRINTF_FORMAT, uid);
! 	printf(" ");
! 	printf(UID_PRINTF_FORMAT, fuid);
! 	printf(" ");
! 	printf(UID_PRINTF_FORMAT, luid);
! 	printf("\n");
! #else
! 	for (EventMap_t::const_iterator i = EventList.begin();
! 			 i != EventList.end(); ++i)
! 		{
! 			if (i->first.second == uid) return i->second; // Found it
! 		}
! #endif
!   return NULL;
  }
  
! Event* MapScheduler::deque()		// next event (removes from q)
  {
!   if (EventList.size() == 0) return NULL; // HuH?
!   EventMap_t::iterator i = EventList.begin();
!   Event* p = i->second;
! #ifdef USING_UIDDEQ
!   CleanUID();
!   if (UIDDeq.size() == 0)
!     { 
!       printf("HuH? MapScheduler::deque, empty uid list\n");
!     }
!   else
!     {
!       if (i->second->uid_ != UIDDeq[0]->uid_)
!         {
!           if (i->second->uid_ >= fuid && i->second->uid_ < luid)
!             { // Not in order, just null it out
! 							UIDDeq[i->second->uid_ - fuid] = NULL;
!             }
!           else
!             {
!               printf("HuH? MapScheduler::deque, uid %ld outofrange %ld %ld\n",
!                      (unsigned long) i->second->uid_,
!                      (unsigned long) fuid,
!                      (unsigned long) luid);
!             }
!         }
!       else
!         { // Is head of list, just remove it
!           UIDDeq.pop_front(); // Remove
! 					fuid++;
!         }
!     }
! #endif
!   EventList.erase(i);
! 	hint = EventList.end();
!   totrm++;
!   return p;
! }
! 
! Event* MapScheduler::earliest()		// earliest event (do not remove)
! {
!   if (EventList.size() == 0) return NULL; // HuH?
!   EventMap_t::iterator i = EventList.begin();
!   return i->second;
! }
! 
! void MapScheduler::CleanUID()
! {
! #ifdef USING_UIDDEQ
!   while(UIDDeq.size() > 0 && UIDDeq[0] == NULL)
!     { // Remove null entries
!       UIDDeq.pop_front();
!       fuid++;
!     }
! #endif
! }
! 
! void MapScheduler::DBDump(const char* pMsg)
! {
!   EventMap_t::const_iterator i;
! 	if (pMsg) printf(pMsg);
! 	printf("Dumping event list\n");
! 	for (i = EventList.begin(); i != EventList.end(); ++i)
! 		{
! 			printf("Time %f/%f uid ", i->first.first, i->second->time_ );
! 			printf(UID_PRINTF_FORMAT, i->second->uid_);
! 			printf(" e %p\n", i->second);
! 			//Event* e = lookup(i->second->uid_);
! 			//if (e != i->second) printf("Event mismatch, %p %p\n", e, i->second);
! 		}
  }
  
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/common/scheduler-map.h pdns-ia64/ns-allinone-2.27/ns-2.27/common/scheduler-map.h
*** new_p/ns-allinone-2.27/ns-2.27/common/scheduler-map.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/common/scheduler-map.h	Sat Jan 31 14:52:23 2004
***************
*** 0 ****
--- 1,81 ----
+ /* -*-	Mode:C++; c-basic-offset:2; tab-width:2; indent-tabs-mode:t -*- */
+ /*
+  * Copyright (c) 1994 Regents of the University of California.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. All advertising materials mentioning features or use of this software
+  *    must display the following acknowledgement:
+  *	This product includes software developed by the Computer Systems
+  *	Engineering Group at Lawrence Berkeley Laboratory.
+  * 4. Neither the name of the University nor of the Laboratory may be used
+  *    to endorse or promote products derived from this software without
+  *    specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  *
+  */
+ 
+ // Event Scheduler using the Standard Template Library map and deque
+ // Contributed by George F. Riley, Georgia Tech.  Spring 2002
+ // Modified by Alfred Park for compatibility with ns-2.26
+ 
+ #ifndef __SCHEDULER_MAP_H__
+ #define __SCHEDULER_MAP_H__
+ 
+ #include <map>
+ #include <deque>
+ 
+ #include "scheduler.h"
+ 
+ typedef pair<double,scheduler_uid_t> KeyPair_t; // The key for the multimap
+ typedef map<KeyPair_t, Event*, less<KeyPair_t> > EventMap_t;
+ typedef deque<Event*> UIDDeq_t;                 // For looking up ev by uid
+ 
+ class MapScheduler : public Scheduler {
+ public:
+   MapScheduler();
+   virtual ~MapScheduler();
+ public:
+   int command(int argc, const char*const* argv);
+   virtual void cancel(Event*);	                // cancel event
+   virtual void insert(Event*);	                // schedule event
+   virtual Event* lookup(scheduler_uid_t uid);	// look for event
+   virtual Event* deque();		        // next event (removes from q)
+   virtual Event* head() { return earliest(); }
+   virtual Event* earliest();                    // earliest, don't remove
+ protected:
+   EventMap_t      EventList;                    // The actual event list
+ #ifdef USING_UIDDEQ
+ 	UIDDeq_t        UIDDeq;                       // DEQ Lookup
+ #endif
+   scheduler_uid_t fuid;
+   scheduler_uid_t luid;   // First and last+1 in UIDDeq
+   unsigned long   totev;  // Total events (debug)
+   unsigned long   totrm;  // Total events removed (debug)
+ 	bool            verbose;// True if verbose debug
+ 	unsigned long   verbosemod;  // Mod factor for verbosity
+   EventMap_t::iterator hint;   // Hint for insertions (right after prior)
+ private:
+   void CleanUID();        // Clean up the UID Deq
+   void DBDump(const char* pMsg = NULL);          // Debug Dump
+ };
+ 
+ #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/common/scheduler.cc pdns-ia64/ns-allinone-2.27/ns-2.27/common/scheduler.cc
*** new_p/ns-allinone-2.27/ns-2.27/common/scheduler.cc	Wed Jan 28 20:50:01 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/common/scheduler.cc	Sat Jan 31 14:52:23 2004
***************
*** 52,57 ****
--- 52,62 ----
  #include "mem-trace.h"
  #endif
  
+ // ALFRED packet statistics
+ #include "pktcount.h"
+ unsigned long long pktC;
+ unsigned long long dropPkts;
+ 
  Scheduler* Scheduler::instance_;
  scheduler_uid_t Scheduler::uid_ = 1;
  
***************
*** 119,132 ****
--- 124,148 ----
  {
  	instance_ = this;
  	Event *p;
+   // ALFRED init packet/event counters
+   unsigned long long EvC = 0;
+   pktC = 0;
+   dropPkts = 0;
  	/*
  	 * The order is significant: if halted_ is checked later,
  	 * event p could be lost when the simulator resumes.
  	 * Patch by Thomas Kaemer <Thomas.Kaemer@eas.iis.fhg.de>.
  	 */
+   // ALFRED log start time of actual sim, for PDNS script compatbility
+   Tcl::instance().evalc( "[Simulator instance] sim-start");
  	while (!halted_ && (p = deque())) {
  		dispatch(p, p->time_);
+     EvC++; // ALFRED event count
  	}
+   // ALFRED print out statistics
+   printf("ns event count: %llu\n", EvC);
+   printf("ns packet hop count: %llu\n", pktC);
+   printf("ns drop-tail queue packets dropped: %llu\n", dropPkts);
  }
  
  /*
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/link/delay.cc pdns-ia64/ns-allinone-2.27/ns-2.27/link/delay.cc
*** new_p/ns-allinone-2.27/ns-2.27/link/delay.cc	Wed Jan 28 20:50:06 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/link/delay.cc	Sat Jan 31 14:52:36 2004
***************
*** 41,46 ****
--- 41,49 ----
  #include "mcast_ctrl.h"
  #include "ctrMcast.h"
  
+ // ALFRED packet count stats
+ #include "common/pktcount.h"
+ 
  static class LinkDelayClass : public TclClass {
  public:
  	LinkDelayClass() : TclClass("DelayLink") {}
***************
*** 104,109 ****
--- 107,113 ----
  		s.schedule(target_, p, txt + delay_);
  	}
  	s.schedule(h, &intr_, txt);
+   pktC++; // ALFRED packet count statistics
  }
  
  void LinkDelay::send(Packet* p, Handler*)
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/nix/classifier-nix.cc pdns-ia64/ns-allinone-2.27/ns-2.27/nix/classifier-nix.cc
*** new_p/ns-allinone-2.27/ns-2.27/nix/classifier-nix.cc	Wed Jan 28 20:50:07 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/nix/classifier-nix.cc	Sat Jan 31 14:52:38 2004
***************
*** 25,30 ****
--- 25,31 ----
  
  #include "config.h"
  #ifdef HAVE_STL
+ #ifdef NIXVECTOR
  
  
  #include <stdio.h>
***************
*** 48,53 ****
--- 49,55 ----
  /****************** NixClassifier Methods ************/
  NsObject* NixClassifier::find(Packet* p)
  {
+ if(0){printf("NixClassifier::find\n");fflush(stdout);}//KALYAN
  	if (m_NodeId == NODE_NONE)
  		{
  			printf("NixClassifier::find(), Unknown node id\n");
***************
*** 77,82 ****
--- 79,85 ----
    NsObject* nsobj = pN->GetNsNeighbor(Nix);
  	if(0)printf("Classifier %s, Node %ld next hop %ld (%s)\n",
  				 name(), pN->Id(), n, nsobj->name());
+ if(0){printf("NixClassifier::find returning %p %s\n",nsobj,!nsobj?"?":nsobj->name());fflush(stdout);}//KALYAN
  	return(nsobj); // And return the nexthop head object
  }
  
***************
*** 106,109 ****
  	return (Classifier::command(argc, argv));
  }
   
! #endif // HAVE_STL
--- 109,113 ----
  	return (Classifier::command(argc, argv));
  }
   
! #endif /* NIXVECTOR */
! #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/nix/hdr_nv.cc pdns-ia64/ns-allinone-2.27/ns-2.27/nix/hdr_nv.cc
*** new_p/ns-allinone-2.27/ns-2.27/nix/hdr_nv.cc	Wed Jan 28 20:50:07 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/nix/hdr_nv.cc	Sat Jan 31 14:52:38 2004
***************
*** 27,32 ****
--- 27,33 ----
  #ifdef HAVE_STL
  #include "nix/hdr_nv.h"
  
+ #ifdef NIXVECTOR
  
  // Define the TCL glue for the packet header
  int hdr_nv::offset_;
***************
*** 39,43 ****
  	}
  } class_nvhdr;
  
! 
! #endif // HAVE_STL
--- 40,44 ----
  	}
  } class_nvhdr;
  
! #endif /* NIXVECTOR */
! #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/nix/nixnode.cc pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixnode.cc
*** new_p/ns-allinone-2.27/ns-2.27/nix/nixnode.cc	Wed Jan 28 20:50:07 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixnode.cc	Sat Jan 31 14:52:38 2004
***************
*** 24,29 ****
--- 24,30 ----
  
  #include "config.h"
  #ifdef HAVE_STL
+ #ifdef NIXVECTOR
  
  // STL includes
  #include <vector>
***************
*** 107,112 ****
--- 108,114 ----
      }
    pE= new Edge(WhichN);
    m_Adj.push_back(pE);
+ if(0){printf("NixNode::AddAdj currlist\n");fflush(stdout);EdgeVec_it x;int totn=0;for(x=m_Adj.begin();x!=m_Adj.end();x++){Edge *pe=*x;printf("\tEdge[%d]=%lu\n",totn++,pe->m_n);}printf("\tTotal=%d\n",totn);fflush(stdout);}//KALYAN
  }
  
  int NixNode::IsNeighbor( // TRUE neighbor bit set
***************
*** 124,134 ****
  Edge* pE;
  
    static EdgeVec_it prev;
    if (last.first == NODE_NONE)
      {
        prev = m_Adj.begin();
!       if (prev == (EdgeVec_it) NULL) // ! How can this happen?
!         return(NodeWeight_t(NODE_NONE, 0));
        pE = *prev;
        if(0)printf("NextAdj returning first edge %ld\n",
               pE->m_n);
--- 126,141 ----
  Edge* pE;
  
    static EdgeVec_it prev;
+ if(0){printf("NixNode::NextAdj m_id %ld last.first %u\n",m_id,last.first);fflush(stdout);}//KALYAN
    if (last.first == NODE_NONE)
      {
        prev = m_Adj.begin();
! #if 1 //KALYAN
!       if (prev==m_Adj.end()) // ! How can this happen?
! {printf("Fatal error %s %d\n",__FILE__,__LINE__);exit(1);}//XXX KALYAN
!       //if (prev == NULL) // ! How can this happen?
!       //return(NodeWeight_t(NODE_NONE, 0));
! #endif //KALYAN
        pE = *prev;
        if(0)printf("NextAdj returning first edge %ld\n",
               pE->m_n);
***************
*** 164,169 ****
--- 171,177 ----
  RoutingVec_t Parent;
  RoutingVec_t NextHop;
  
+ if(0){printf("NixNode::ComputeNixVector from %ld to %ld\n",m_id,t);fflush(stdout);}//KALYAN
    if(0)printf("Computing nixvector from %ld to %ld\n", m_id,  t); 
    BFS(Nodes, m_id, NextHop, Parent);
    NixVec* pNv = new NixVec;
***************
*** 192,201 ****
--- 200,211 ----
  
  nodeid_t NixNode::GetNeighbor( Nix_t n, NixVec* pNv)
  { // Reconstruct a neighbor from the neighbor index
+ if( n == NIX_NONE ) return 0;//KALYAN
  	if (n >= m_Adj.size())
  		{ // Foulup of some sort, print stuff out and abort
  			printf("Nix %ld out of range (0 - %d\n", n, m_Adj.size());
  			pNv->DBDump();
+ if(1) return 0;//KALYAN
  			exit(0);
  		}
    return(m_Adj[n]->m_n);
***************
*** 204,216 ****
--- 214,233 ----
  
  NsObject* NixNode::GetNsNeighbor(Nix_t n)   // Get the ns nexthop neighbor
  {
+ if(0){printf("NixNode::GetNsNeighbor sizeof(short)=%d, sizeof(int)=%d\n",sizeof(short),sizeof(int));fflush(stdout);}//KALYAN
+ if(0){printf("NixNode::GetNsNeighbor %u NIX_NONE=%u\n",n,NIX_NONE);fflush(stdout);}//KALYAN
  	if (n >= m_AdjObj.size()) return(NULL);   // Out of range
    return(m_AdjObj[n]);
  }
  
+ #if 0 //KALYAN
  NixVec* NixNode::GetNixVector(nodeid_t t) // Get a nix vector for a target
+ #else //KALYAN
+ NixVec* NixNode::kalyan_GetNixVector(nodeid_t t) // Get a nix vector for a target
+ #endif //KALYAN
  {
  NVMap_it i;
+ if(0){printf("NixNode::GetNixVector %ld\n",t);fflush(stdout);}//KALYAN
  
   if (!m_pNixVecs)
  	 { // No current list
***************
*** 220,225 ****
--- 237,243 ----
   i = m_pNixVecs->find(t);
   if (i == m_pNixVecs->end())
  	 { // Does not exist, compute it and add to the hash-map
+ if(0){static int x=0; if(x<10000||x%10000==0){printf("GetNixVector->ComputeNixVector() %d\n",x);}x++;}//KALYAN
  		 NixVec* pNv = ComputeNixVector(t);
  		 // Debug statistics follow
  		 if (NVCount == 0)
***************
*** 274,280 ****
--- 292,302 ----
  }
  
  // Static functions
+ #if 0 //KALYAN
  NixNode*   NixNode::GetNodeObject(nodeid_t n) // Get a node obj. based on id
+ #else //KALYAN
+ NixNode*   NixNode::kalyan_GetNodeObject(nodeid_t n) // Get a node obj. based on id
+ #endif //KALYAN
  {
  	if (n >= Nodes.size()) return(NULL); // Does not exist
  	return((NixNode*)Nodes[n]);
***************
*** 299,302 ****
--- 321,325 ----
  				 NVCount, NVMin, NVMax, (double)NVTot/(double)NVCount);
  }
  
+ #endif /* NIXVECTOR */
  #endif /* STL */
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/nix/nixnode.h pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixnode.h
*** new_p/ns-allinone-2.27/ns-2.27/nix/nixnode.h	Wed Jan 28 20:50:07 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixnode.h	Sat Jan 31 14:52:38 2004
***************
*** 8,14 ****
  
  #include "routealgo/rnode.h"
  #include "object.h"
! #include <map>
  
  // Define the edge class
  class Edge {
--- 8,14 ----
  
  #include "routealgo/rnode.h"
  #include "object.h"
! #include <map> //KALYAN added .h
  
  // Define the edge class
  class Edge {
***************
*** 42,51 ****
--- 42,61 ----
    virtual NixPair_t GetNix(nodeid_t);       // Get neighbor index/length
    virtual Nixl_t    GetNixl();              // Get bits needed for nix entry
    virtual nodeid_t  GetNeighbor(Nix_t, NixVec*);     // Get neighbor from nix
+ #if 0 //KALYAN
  	NixVec*           GetNixVector(nodeid_t); // Get a nix vector for a target
+ #else //KALYAN
+ 	NixVec*           kalyan_GetNixVector(nodeid_t); // Get a nix vector for a target
+ 	NixVec*           GetNixVector(nodeid_t n){return kalyan_GetNixVector(n);} // Get a nix vector for a target
+ #endif //KALYAN
    NsObject*         GetNsNeighbor(Nix_t);   // Get the ns nexthop neighbor
  	void    PopulateObjects(void);       // Populate NS NextHop objects
+ #if 0 //KALYAN
    static NixNode*   GetNodeObject(nodeid_t); // Get a node obj. based on id
+ #else //KALYAN
+   static NixNode*   kalyan_GetNodeObject(nodeid_t);
+   static NixNode*   GetNodeObject(nodeid_t n){return kalyan_GetNodeObject(n);} // Get a node obj. based on id
+ #endif //KALYAN
    static void       PopulateAllObjects(void);// Populate the next hop objects
  private :
    EdgeVec_t    m_Adj;             // Adjacent edges
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/nix/nixroute.cc pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixroute.cc
*** new_p/ns-allinone-2.27/ns-2.27/nix/nixroute.cc	Wed Jan 28 20:50:07 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixroute.cc	Sat Jan 31 14:52:38 2004
***************
*** 25,30 ****
--- 25,31 ----
  
  #include "config.h"
  #ifdef HAVE_STL
+ #ifdef NIXVECTOR
  
  #include "rtmodule.h"
  
***************
*** 53,57 ****
  
  }  
  
! 
! #endif //HAVE_STL
--- 54,58 ----
  
  }  
  
! #endif /* NIXVECTOR */
! #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/nix/nixvec.cc pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixvec.cc
*** new_p/ns-allinone-2.27/ns-2.27/nix/nixvec.cc	Wed Jan 28 20:50:07 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixvec.cc	Sat Jan 31 14:52:38 2004
***************
*** 24,29 ****
--- 24,30 ----
  
  #include "config.h"
  #ifdef HAVE_STL
+ #ifdef NIXVECTOR
  
  #include <string.h> // for memcpy
  #include <stdio.h>
***************
*** 34,39 ****
--- 35,41 ----
  // Constructor from existing
  NixVec::NixVec(NixVec* p) : m_used(0), m_alth(p->m_alth)
  {
+ if(0){printf("NixVec::NixVec this=%p m_alth=%u p=%p p->m_alth=%u\n",this,m_alth,p,p->m_alth);fflush(stdout);}//KALYAN
    if (Lth() > NIX_BPW)
      { // Need to allocate storage
        m_pNV = new Nix_t[Lth() / NIX_BPW];
***************
*** 53,58 ****
--- 55,61 ----
  
  void NixVec::Add( NixPair_t p)
  { // Add some bits to the nix vector
+ if(0){printf("NixVec::Add this=%p m_alth=%u p.second=%u\n",this,m_alth,p.second);fflush(stdout);}//KALYAN
    Nixl_t newused;
    Nix_t  newbits;
    Nixl_t newlth;
***************
*** 130,135 ****
--- 133,139 ----
          }
      }
    m_used = newused;
+ if(0){if(m_used>m_alth)printf("NixVec::Add overwriting m_alth %u with m_used %u\n",m_alth,m_used);fflush(stdout);}//KALYAN
    if (m_used > m_alth) m_alth = m_used;
  #ifdef NEED_DEBUG
    if (!db)
***************
*** 148,193 ****
  Nix_t NixVec::Extract(Nixl_t n, Nixl_t* pUsed)
  { // Get the next "n" bits from the vec
    Nixl_t used = *pUsed;
    
    Nixl_t word = used / NIX_BPW;
    Nixl_t bit  = used - (word * NIX_BPW);
    long  m     = 0x80000000; // n bit mask
    Nix_t  w;
  
!   if(0)printf("Extracting %ld bits, used %ld lth %ld alth %ld\n", 
           n, used, Lth(), m_alth);
     if ((used + n) > m_alth) return(NIX_NONE); // Overflow
     if ((bit + n) <= NIX_BPW)
       { // Simple case
         if (Lth() == NIX_BPW)
!          w = (long)m_pNV;
         else
           w = m_pNV[word];
!        m >>= (n-1); // n bit mask
         Nix_t u = (Nix_t)m;
         u >>= bit;   // position mask
         w &= u;      // extract the bits
         w >>= (NIX_BPW - bit - n);
       }
     else
       { // spans a word
         if (Lth() == NIX_BPW)
!          w = (long)m_pNV;
         else
           w = m_pNV[word];
         Nixl_t t = NIX_BPW - bit; // Number bits in first word
!        m >>= (t-1); // n bit mask
         Nix_t u = (Nix_t)m;
         u >>= bit;   // position mask
         w &= u;
         t = n - t;   // number bits in second word
         w <<= t;
         m = 0x80000000; // n bit mask
!        m >>= (t-1);
         w |= (m_pNV[word+1] >> (NIX_BPW - t));
       }
     used += n;
     *pUsed = used; // Return advanced
     return(w);
  }
  
--- 152,213 ----
  Nix_t NixVec::Extract(Nixl_t n, Nixl_t* pUsed)
  { // Get the next "n" bits from the vec
    Nixl_t used = *pUsed;
+ if(0){printf("NixVec::Extract n=%u used=%u m_pNV=%p\n",n,used,m_pNV);fflush(stdout);}//KALYAN
    
    Nixl_t word = used / NIX_BPW;
    Nixl_t bit  = used - (word * NIX_BPW);
    long  m     = 0x80000000; // n bit mask
    Nix_t  w;
+ if(0){printf("NixVec::Extract word=%u bit=%u m=%u\n",word,bit,m);fflush(stdout);}//KALYAN
  
!   if(0)printf("Extracting %u bits, used %u lth %u alth %u\n", 
           n, used, Lth(), m_alth);
+ if(0){if((used+n)>m_alth)printf("NixVec::Extract overflow\n");fflush(stdout);}//KALYAN
     if ((used + n) > m_alth) return(NIX_NONE); // Overflow
     if ((bit + n) <= NIX_BPW)
       { // Simple case
+ if(0){printf("NixVec::Extract simple case\n");fflush(stdout);}//KALYAN
+ if(0){printf("Before: (c=%d) m %x\n",(Lth() == NIX_BPW),m);fflush(stdout);}//KALYAN
         if (Lth() == NIX_BPW)
!          w = (/*KALYAN long*/int)m_pNV;
         else
           w = m_pNV[word];
!        //XXX KALYAN m >>= (n-1); // n bit mask
! m = (((Nix_t)(0xffffffffU)) << (32-n));//XXX KALYAN
         Nix_t u = (Nix_t)m;
+ if(0){printf("After: w %x m %x u %x\n",w,m,u);fflush(stdout);}//KALYAN
         u >>= bit;   // position mask
+ if(0){printf("After u>>=bit u=%x\n",u);fflush(stdout);}//KALYAN
         w &= u;      // extract the bits
+ if(0){printf("After w&=u w=%x\n",w);fflush(stdout);}//KALYAN
         w >>= (NIX_BPW - bit - n);
+ if(0){printf("After w>>=%d w=%x\n",(NIX_BPW - bit - n),w);fflush(stdout);}//KALYAN
       }
     else
       { // spans a word
+ if(0){printf("NixVec::Extract complex case\n");fflush(stdout);}//KALYAN
         if (Lth() == NIX_BPW)
!          w = (/*KALYAN long*/int)m_pNV;
         else
           w = m_pNV[word];
         Nixl_t t = NIX_BPW - bit; // Number bits in first word
!        //XXX KALYAN m >>= (t-1); // n bit mask
! m = (((Nix_t)(0xffffffffU)) << (32-t));//XXX KALYAN
         Nix_t u = (Nix_t)m;
         u >>= bit;   // position mask
         w &= u;
         t = n - t;   // number bits in second word
         w <<= t;
         m = 0x80000000; // n bit mask
!        //XXX KALYAN m >>= (t-1);
! m = (((Nix_t)(0xffffffffU)) << (32-t));//XXX KALYAN
         w |= (m_pNV[word+1] >> (NIX_BPW - t));
+ if(0){static int x=0; if(x<10000||x%10000==0){printf("NixVec::Extract() %d complex case returning %u\n",w);}x++;}//KALYAN
       }
     used += n;
     *pUsed = used; // Return advanced
+ if(0){printf("NixVec::Extract returning %u\n",w);fflush(stdout);}//KALYAN
+ if(0){printf("Extracted %ld bits, used %lu lth %u alth %u m_pNV %p\n",n,used,Lth(),m_alth,m_pNV);fflush(stdout);}//KALYAN
     return(w);
  }
  
***************
*** 206,215 ****
--- 226,239 ----
      }
  }
  
+ #if 0 //KALYAN
  void NixVec::Reset()
+ #else
+ void NixVec::kalyan_Reset()
  {
    m_used = 0; // Reset to beginning
  }
+ #endif //KALYAN
  
  // Static functions
  Nixl_t NixVec::GetBitl( Nixl_t l)
***************
*** 305,308 ****
--- 329,333 ----
  
  #endif
  
+ #endif /* NIXVECTOR */
  #endif /* STL */
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/nix/nixvec.h pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixvec.h
*** new_p/ns-allinone-2.27/ns-2.27/nix/nixvec.h	Wed Jan 28 20:50:07 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/nix/nixvec.h	Sun Feb  1 16:36:28 2004
***************
*** 25,39 ****
  #define __NIXVEC_H__
  
  #include <utility>  // for pair
! #ifdef WIN32
! #include <pair.h>   // for MSVC 6.0 that doens't have a proper <utility>
! #endif /* WIN32 */
  
! // Define a type for the neighbor index
  typedef unsigned long Nix_t;
  typedef unsigned long Nixl_t; // Length of a NV
  const   Nix_t NIX_NONE = 0xffffffff;    // If not a neighbor
  const   Nixl_t NIX_BPW = 32;            // Bits per long word
  typedef pair<Nix_t,  Nixl_t> NixPair_t; // Index, bits needed
  typedef pair<Nix_t*, Nixl_t> NixpPair_t;// NV Pointer, length
  
--- 25,51 ----
  #define __NIXVEC_H__
  
  #include <utility>  // for pair
! //#include <deque>  // for pair //KALYAN added
! //#ifdef WIN32
! //#include <pair.h>   // for MSVC 6.0 that doens't have a proper <utility>
! //#endif /* WIN32 */
  
! class NixVec;
! 
! #if 1 //KALYAN
! typedef unsigned int Nix_t;
! typedef unsigned int Nixl_t; // Length of a NV
! #else //KALYAN
  typedef unsigned long Nix_t;
  typedef unsigned long Nixl_t; // Length of a NV
+ #endif //KALYAN
+ #if 1 //KALYAN
  const   Nix_t NIX_NONE = 0xffffffff;    // If not a neighbor
  const   Nixl_t NIX_BPW = 32;            // Bits per long word
+ #else //KALYAN
+ const   Nix_t NIX_NONE = 0xffffffffffffffffUL;    // If not a neighbor
+ const   Nixl_t NIX_BPW = 64;            // Bits per long word
+ #endif //KALYAN
  typedef pair<Nix_t,  Nixl_t> NixPair_t; // Index, bits needed
  typedef pair<Nix_t*, Nixl_t> NixpPair_t;// NV Pointer, length
  
***************
*** 48,54 ****
--- 60,71 ----
      Nix_t  Extract(Nixl_t);       // Extract the specified number of bits
      Nix_t  Extract(Nixl_t, Nixl_t*); // Extract using external "used"
      NixpPair_t Get(void);         // Get the entire nv
+ #if 0
      void   Reset();               // Reset used to 0
+ #else
+     void   kalyan_Reset();
+     void   Reset(){kalyan_Reset();}               // Reset used to 0
+ #endif //KALYAN
      Nixl_t Lth();                 // Get length in bits of allocated
      void   DBDump();              // Debug..print it out
      Nixl_t ALth() { return m_alth;} // Debug...how many bits actually used
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/queue/drop-tail.cc pdns-ia64/ns-allinone-2.27/ns-2.27/queue/drop-tail.cc
*** new_p/ns-allinone-2.27/ns-2.27/queue/drop-tail.cc	Wed Jan 28 20:50:06 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/queue/drop-tail.cc	Sat Jan 31 14:52:35 2004
***************
*** 39,44 ****
--- 39,47 ----
  
  #include "drop-tail.h"
  
+ // ALFRED packet statistics
+ #include "common/pktcount.h"
+ 
  static class DropTailClass : public TclClass {
   public:
  	DropTailClass() : TclClass("Queue/DropTail") {}
***************
*** 99,104 ****
--- 102,108 ----
  		} else {
  			drop(p);
  		}
+     dropPkts++; // ALFRED droptail queue packet stats
  	} else {
  		q_->enque(p);
  	}
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/queue/jobs.h pdns-ia64/ns-allinone-2.27/ns-2.27/queue/jobs.h
*** new_p/ns-allinone-2.27/ns-2.27/queue/jobs.h	Wed Jan 28 20:50:06 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/queue/jobs.h	Mon Feb  2 17:59:03 2004
***************
*** 64,70 ****
  
  /* JoBS Queuing */
  #ifndef INFINITY
! #define	INFINITY	+1.0e499
  #endif
  #define	PRECISION_ERROR +1.0e-10
  #define TOL		0.02		// Tolerance in the constraints (2%)
--- 64,72 ----
  
  /* JoBS Queuing */
  #ifndef INFINITY
! // ALFRED change for icc/ecc compatibility
! //#define	INFINITY	+1.0e499
! #define INFINITY 1.797693e+308
  #endif
  #define	PRECISION_ERROR +1.0e-10
  #define TOL		0.02		// Tolerance in the constraints (2%)
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/hdr_rti.cc pdns-ia64/ns-allinone-2.27/ns-2.27/rti/hdr_rti.cc
*** new_p/ns-allinone-2.27/ns-2.27/rti/hdr_rti.cc	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/hdr_rti.cc	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,25 ----
+ // Define the packet header for the pdns/rti information
+ // George F. Riley, Georgia Tech, Winter 2000
+ 
+ #include "hdr_rti.h"
+ 
+ // Define the TCL glue for the packet header
+ int hdr_rti::offset_;
+ 
+ static class RTIHeaderClass : public PacketHeaderClass {
+ public:
+         RTIHeaderClass() : PacketHeaderClass("PacketHeader/RTI",
+ 					    sizeof(hdr_rti)) {
+           //printf("Binding offset\n");
+ 	  bind_offset(&hdr_rti::offset_);
+ 	  //printf("Done Binding Offset\n");
+ 
+ 	}
+         void export_offsets() {
+               field_offset("ipsrc_", OFFSET(hdr_rti, ipsrc_));
+               field_offset("ipsrc_port_", OFFSET(hdr_rti, ipsrc_port_));
+ 	      field_offset("ipdst_", OFFSET(hdr_rti, ipdst_));
+               field_offset("ipdst_port_", OFFSET(hdr_rti, ipdst_port_));
+         }
+ 
+ } class_rtihdr;
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/hdr_rti.h pdns-ia64/ns-allinone-2.27/ns-2.27/rti/hdr_rti.h
*** new_p/ns-allinone-2.27/ns-2.27/rti/hdr_rti.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/hdr_rti.h	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,45 ----
+ // Define the packet header for the pdns/rti information
+ // George F. Riley, Georgia Tech, Winter 2000
+ 
+ #ifndef __HDR_RTI_H__
+ #define __HDR_RTI_H__
+ 
+ #include "packet.h"
+ 
+ typedef unsigned int ipaddr_t;
+ typedef int ipportaddr_t;
+ 
+ struct hdr_rti {
+   ipaddr_t        ipsrc_;
+   ipportaddr_t    ipsrc_port_;
+   ipaddr_t        ipdst_;
+   ipportaddr_t    ipdst_port_;
+   unsigned long   RTINodeId_; // Node id of originator
+   static int offset_;
+   inline static int& offset() { return offset_; }
+   inline static hdr_rti* access(Packet* p) {
+     return (hdr_rti*) p->access(offset_);
+   }
+ 
+   /* per-field member acces functions */
+ 
+   ipaddr_t& ipsrc() {
+     return ipsrc_;
+   }
+   ipportaddr_t& ipsrcport() {
+     return ipsrc_port_;
+   }
+   ipaddr_t& ipdst() {
+     return ipdst_;
+   }
+   ipportaddr_t& ipdstport() {
+     return ipdst_port_;
+   }
+ 
+   unsigned long& RTINodeId() {
+     return RTINodeId_;
+   }
+ };
+ 
+ 
+ #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/liveapp.cc pdns-ia64/ns-allinone-2.27/ns-2.27/rti/liveapp.cc
*** new_p/ns-allinone-2.27/ns-2.27/rti/liveapp.cc	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/liveapp.cc	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,509 ----
+ /*---------------------------------------------------------------------------*/
+ /*
+  *  Support for routing live application traffic via ns
+  *    - Kalyan Perumalla <http:/www.cc.gatech.edu/~kalyan> 15 June 2001
+  */
+ /*---------------------------------------------------------------------------*/
+ 
+ #include <iostream.h>
+ #include <map.h>
+ #include <vector.h>
+ 
+ #include "liveapp.h"
+ 
+ extern "C" {
+ #include "veilmsg.h"
+ #include "buffers.h"
+ #include "veilmsg.c"
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ #include <assert.h>
+ #define ASSERT( _cond, _act ) do{ \
+         if( !(_cond) ) { \
+ 	    printf _act; \
+ 	    printf( "\n" ); \
+ 	    assert( _cond ); \
+ 	} \
+     }while(0)
+ 
+ /*---------------------------------------------------------------------------*/
+ static double LOOKAHEAD = 1.0*MICROSEC;
+ struct
+ {
+     double lconnect;
+     double ldisconnect;
+     double lsocket_data;
+     double ldata_notify;
+ } latency =
+ {
+     LOOKAHEAD,
+     LOOKAHEAD,
+     LOOKAHEAD,
+     LOOKAHEAD
+ };
+ 
+ /*---------------------------------------------------------------------------*/
+ struct LiveAppData
+ {
+     LiveApplication *app;
+ };
+ typedef map<SockPort,LiveAppData> AppPortMap;
+ 
+ /*---------------------------------------------------------------------------*/
+ class AppList : public vector<LiveApplication*>
+ {
+     public: LiveApplication *top_app( void )
+         { return size() > 0 ? (*this)[0] : 0; }
+     public: void add_app( LiveApplication *app )
+         { push_back( app ); }
+     public: void del_app( LiveApplication *app )
+     {
+ 	int i = 0, j = -1, n = size();
+         for( i = 0; i < n; i++ )
+ 	{
+ 	    if( (*this)[i] == app ) { j = i; }
+ 	    if( j >= 0 && i < n-1 ) (*this)[i] = (*this)[i+1];
+ 	}
+ 	ASSERT( j >= 0, ("App must exist") );
+ 	pop_back();
+     }
+ };
+ 
+ /*---------------------------------------------------------------------------*/
+ struct LiveHostData
+ {
+     RTI_ObjClassDesignator a2n_class;
+     RTI_ObjClassDesignator n2a_class;
+     RTI_ObjInstanceDesignator n2a_instance;
+     AppList unbound_apps;
+     AppPortMap port_map;
+ };
+ typedef map<SockAddr,LiveHostData> HostAddrMap;
+ static HostAddrMap addr_map;
+ 
+ /*---------------------------------------------------------------------------*/
+ /*---------------------------------------------------------------------------*/
+ static void forward_veil_msg( VeilMsg *vmsg, TM_Time delay )
+ {
+     LiveHostData &hdata = addr_map[vmsg->dest_ip];
+ 
+     RTI_ObjInstanceDesignator objinst = hdata.n2a_instance;
+     int len = sizeof( VeilMsg );
+     struct MsgS *msg = &vmsg->rti_data;
+     msg->TimeStamp += delay;
+     RTI_UpdateAttributeValues( objinst, msg, len, VEIL_MSG_TAG );
+ 
+     double now= Scheduler::instance().clock();
+ 
+ if(1){printf( "Now=%lf, forwarded veil msg\n", now ); print_veilmsg_hdr( stdout, vmsg ); fflush(stdout);}
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void veil_recv( char *cp )
+ {
+     VeilMsg *vmsg = (VeilMsg *)cp;
+ 
+ if(1){printf("veil_recv() recd veil msg\n"); print_veilmsg_hdr(stdout, vmsg);}
+ 
+     LiveHostData &src_data = addr_map[vmsg->src_ip];
+     LiveAppData &src_app_data = src_data.port_map[vmsg->src_port];
+     LiveApplication *src_app = src_app_data.app;
+ 
+     LiveHostData &dest_data = addr_map[vmsg->dest_ip];
+     LiveAppData &dest_app_data = dest_data.port_map[vmsg->dest_port];
+     LiveApplication *dest_app = dest_app_data.app;
+ 
+     switch( vmsg->type )
+     {
+         case VEIL_MSG_CONNECT_REQ:
+         case VEIL_MSG_CONNECT_RESP:
+ 	{
+ 	    /*Bind a LiveApplication object to this connection,if none already*/
+ 	    if( !src_app )
+ 	    {
+ 	        LiveApplication *app = src_data.unbound_apps.top_app();
+ 		ASSERT( app, ("At least one unbound app must exist") );
+ 		app->bind_local( vmsg->src_port );
+                 src_app = src_app_data.app;
+ 		ASSERT( src_app == app, ("App should be bound by now") );
+ 		src_app->bind_peer( vmsg->dest_ip, vmsg->dest_port );
+ 	        src_app->nomore_data = false;
+ 
+ 		/*If our agent is FullTCP, force it to connect*/
+ 		if( vmsg->type == VEIL_MSG_CONNECT_REQ )
+ 		    src_app->initiate_connect();
+ 	    }
+ 
+ 	    /*Forward this request directly to dest, since ns has no SYN*/
+ 	    forward_veil_msg( vmsg, latency.lconnect );
+ 	    break;
+ 	}
+         case VEIL_MSG_DATA_NOTIFY:
+ 	{
+ 	    ASSERT( 0, ("Can't reach here") );
+ 	    break;
+ 	}
+         case VEIL_MSG_SOCKET_DATA:
+ 	{
+             /*Forward this data message to destination application*/
+             forward_veil_msg( vmsg, latency.lsocket_data );
+ 
+ 	    ASSERT( src_app, ("Application must be bound") );
+             src_app->send( vmsg->msg.sdata.datalen );
+ 
+ 	    break;
+ 	}
+         case VEIL_MSG_DISCONNECT:
+ 	{
+ 	    ASSERT( src_app, ("") );
+ 	    src_app->disconnect();
+ 	    break;
+ 	}
+         default:
+ 	{
+ 	    ASSERT( 0, ("Bad veil message type %d\n", vmsg->type) );
+ 	    break;
+ 	}
+     }
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ typedef char AddressString[100];
+ static class LiveApplicationClass : public TclClass
+ {
+  public:
+ 	LiveApplicationClass() :
+ 	    TclClass("Application/LiveApplication"), inited(false) {}
+ 	TclObject* create( int argc, const char*const*argv )
+ 	{
+ 	        cout << "LiveApplication::new()" << endl;
+ if(1){cout << "argc=" << argc << endl; for(int i=0;i<argc;i++)cout<<" \""<<argv[i]<<"\""; cout << endl;}
+ 		if( !inited ) { init_groups(); inited = true; }
+ 		SockAddr ipaddr = 0;
+ 		SockPort port = 0;
+ 		ASSERT(argc > 4, ("LiveApplication creation needs IP address"));
+ 		if( argc > 4 ) { ipaddr = dot_to_ulong( argv[4] ); }
+ 		if( argc > 5 ) { port = atoi( argv[5] ); }
+ 		return (new LiveApplication( ipaddr, port ));
+ 	}
+  private:
+ 	void init_groups( void );
+ 	void read_addresses( AddressString addrs[], int maxn, int *rn );
+ 	bool inited;
+ 	static char *MyWhereProc( long, void *, long );
+ 	static VeilMsg *alloc_veilmsg( void );
+ } class_application;
+ 
+ /*---------------------------------------------------------------------------*/
+ extern MB_BufferPool RTIFreePool;
+ VeilMsg *LiveApplicationClass::alloc_veilmsg( void )
+ {
+   VeilMsg *buf = (VeilMsg *)MB_GetBuffer(RTIFreePool);
+  
+   return buf;
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ char *LiveApplicationClass::MyWhereProc(long MsgSize, void *ctxt, long MsgType)
+ {
+   char * buf;
+  
+   ASSERT( MsgSize == sizeof(VeilMsg), ("WhereProc: bad msg size") );
+   ASSERT( MsgType == VEIL_MSG_TAG, ("WhereProc: bad msg type") );
+  
+   buf = (char*)alloc_veilmsg();
+  
+   return buf;
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplicationClass::read_addresses( AddressString addrs[],
+     int maxn, int *rn )
+ {
+     int i = 0, n = maxn;
+ 
+     *rn = 0;
+     for( i = 0; i < n; i++ )
+     {
+         sprintf( addrs[i], "192.168.0.%d", i+1 );
+ 	(*rn)++;
+     }
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplicationClass::init_groups( void )
+ {
+   #define MAXADDRESSES 2
+   AddressString addrs[MAXADDRESSES];
+   int i = 0, j = 0, n = 0;
+ 
+   read_addresses( addrs, MAXADDRESSES, &n );
+ 
+   for( j = 0; j < n; j++ )
+   {
+       char cn[100];
+       struct in_addr inp;
+       int retval = inet_aton( addrs[j], &inp );
+       SockAddr ip_addr = inp.s_addr;
+ 
+       ASSERT( retval, ("inet_aton(\"%s\")=%d", addrs[j], retval) );
+ 
+       LiveHostData &hdata = addr_map[ip_addr];
+ 
+       sprintf( cn, "A2N:%s", addrs[j] );
+       hdata.a2n_class = RTI_CreateClass( cn );
+       ASSERT( hdata.a2n_class, ("Can't create %s class", cn) );
+ 
+       sprintf( cn, "N2A:%s", addrs[j] );
+       hdata.n2a_class = RTI_CreateClass( cn );
+       ASSERT( hdata.n2a_class, ("Can't create %s class\n", cn) );
+   }
+ 
+ if(0) RTIKIT_Barrier(); /*Indicate to everyone that all classes are created*/
+ 
+   for( j = 0; j < n; j++ )
+   {
+       char cn[100];
+       struct in_addr inp;
+       int retval = inet_aton( addrs[j], &inp );
+       SockAddr ip_addr = inp.s_addr;
+ 
+       LiveHostData &hdata = addr_map[ip_addr];
+ 
+       RTI_PublishObjClass( hdata.n2a_class );
+       hdata.n2a_instance = RTI_RegisterObjInstance( hdata.n2a_class );
+ 
+       if( !RTI_IsClassSubscriptionInitialized( hdata.a2n_class ) )
+         RTI_InitObjClassSubscription( hdata.a2n_class, MyWhereProc, 0 );
+       RTI_SubscribeObjClassAttributes( hdata.a2n_class );
+   }
+ 
+ if(0) RTIKIT_Barrier(); /*wait until all are subscribed before sending messages*/
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ LiveApplication::LiveApplication( long a, long p )
+ {
+ 	cout << "@ " << Scheduler::instance().clock() << " ";
+ 	cout << ": " << "LiveApplication::constructor("
+ 	     << ulong_to_dot(a) << ":" << p << " )" << endl;
+ 
+ 	enableRecv_ = 0;
+ 	enableResume_ = 0;
+ 
+         local.addr = a; local.port = p;
+ 	peer.addr = 0; peer.port = 0;
+ 	tosend.bytes = sent.bytes = recd.bytes = 0;
+ 	awaiting_resume = true;
+ 
+ 	SockAddr ipaddr = local.addr;
+ 	LiveHostData &hdata = addr_map[ipaddr];
+ 	hdata.unbound_apps.add_app( this );
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ int LiveApplication::command(int argc, const char*const* argv)
+ {
+ 	cout << "@ " << Scheduler::instance().clock() << " ";
+ 	cout << name_ << ": " << "LiveApplication::command(argc="
+ 	     << argc << ")" << endl;
+ 	for(int i=0;i<argc;i++){cout<<" \""<<argv[i]<<"\"";}cout<<endl;
+ 	return (Application::command(argc, argv));
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::bind_local( long port )
+ {
+ 	cout << "@ " << Scheduler::instance().clock() << " ";
+ 	cout << name_ << ": " << "LiveApplication::bind_local(port="
+ 	     << port << ")" << endl;
+ 
+ 	ASSERT( local.port <= 0 || local.port == port, ("Bad port number") );
+ 
+ 	if( local.port <= 0 )
+ 	{
+ 	    local.port = port;
+ 
+ 	    SockAddr ipaddr = local.addr;
+ 	    SockPort portnum = local.port;
+             LiveHostData &hdata = addr_map[ipaddr];
+ 
+ 	    hdata.unbound_apps.del_app( this );
+ 
+             LiveAppData &adata = hdata.port_map[portnum];
+             adata.app = this;
+ 	}
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::unbind_local( void )
+ {
+ 	cout << "@ " << Scheduler::instance().clock() << " ";
+ 	cout << name_ << ": " << "LiveApplication::unbind_local()" << endl;
+ 
+ 	if( local.port > 0 )
+ 	{
+ 	    SockAddr ipaddr = local.addr;
+ 	    SockPort portnum = local.port;
+ 	    LiveHostData &hdata = addr_map[ipaddr];
+ 
+ 	    LiveAppData &adata = hdata.port_map[portnum];
+ 	    adata.app = 0;
+ 
+ 	    hdata.unbound_apps.add_app( this );
+ 	    local.port = 0;
+ 	}
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::bind_peer( long addr, long port )
+ {
+ 	cout << "@ " << Scheduler::instance().clock() << " ";
+ 	cout << name_ << ": " << "LiveApplication::bind_peer(addr=" << addr
+ 	     << ", port=" << port << ")" << endl;
+ 	
+ 	peer.addr = addr;
+ 	peer.port = port;
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::initiate_connect( void )
+ {
+     if(1)Application::send( 0 );
+     awaiting_resume = true;
+ cout << name_ << ": initiate_connect()" << endl;
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::start()
+ {
+ 	cout << "@ " << Scheduler::instance().clock() << " ";
+ 	cout << name_ << ": " << "LiveApplication::start() "
+ 	     << ulong_to_dot(local.addr) << ":" << local.port << endl;
+ 
+ 	tosend.bytes = sent.bytes = recd.bytes = 0;
+ 	awaiting_resume = true;
+ 	nomore_data = false;
+ 
+ 	if( local.port > 0 ) { bind_local( local.port ); }
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::stop()
+ {
+ 	double now = Scheduler::instance().clock();
+ 	cout << "@ " << now << " ";
+ 	cout << name_ << ": " << "LiveApplication::stop()" << endl;
+ 
+ 	nomore_data = true;
+ 	if( awaiting_resume )
+ 	{
+ cout << name_ << ": " << "Skipping stop waiting for pending resume." << endl;
+ 	}
+ 	else
+ 	{
+ 	    if( local.port > 0 )
+ 	    {
+ 	        VeilMsg vmsg;
+ 	        SockAddr src_ip = local.addr;
+ 	        SockPort src_port = local.port;
+ 	        SockAddr dest_ip = peer.addr;
+ 	        SockPort dest_port = peer.port;
+ 	        set_veil_msg( &vmsg, VEIL_MSG_DISCONNECT,
+ 	                      src_ip, src_port, dest_ip, dest_port );
+ 	        set_veil_msg_disconnect( &vmsg.msg.dcon, sent.bytes );
+ 	        vmsg.rti_data.TimeStamp = now;
+ 	        forward_veil_msg( &vmsg, latency.ldisconnect );
+ cout << name_ << ": " << "Forwarded DISCONNECT: totbytes=" << sent.bytes <<endl;
+ 	        unbind_local();
+ 	    }
+ 
+ 	    sent.bytes = recd.bytes = 0;
+ 	    nomore_data = false;
+ 	}
+ cout << name_ << ": " << "done stop" << endl;
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::send(int nbytes)
+ {
+ 	cout << "@ " << Scheduler::instance().clock() << " ";
+ 	cout << name_ << ": " << "LiveApplication::send(" << nbytes <<")"<<endl;
+ 
+ 	if( awaiting_resume )
+ 	{
+ 	    tosend.bytes += nbytes;
+ cout << name_ << ": " << "Enqueueing " << nbytes << endl;
+ 	}
+ 	else
+ 	{
+ 	    ASSERT( tosend.bytes == 0, ("") );
+ 	    Application::send(nbytes);
+ cout << name_ << ": " << "Sending " << nbytes << endl;
+ 	}
+ 
+ 	sent.bytes += nbytes;
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::recv(int nbytes)
+ {
+ 	double now = Scheduler::instance().clock();
+ 	cout << "@ " << now << " ";
+ 	cout << name_ << ": " << "LiveApplication::recv(" << nbytes <<")"<<endl;
+ 
+ 	if( nbytes <= 0 ) return;
+ 
+ 	recd.bytes += nbytes;
+ 
+ 	/*Notify actual application that additional nbytes can be delivered*/
+ 	{
+ 	    VeilMsg vmsg;
+ 	    SockAddr src_ip = peer.addr;
+ 	    SockPort src_port = peer.port;
+ 	    SockAddr dest_ip = local.addr;
+ 	    SockPort dest_port = local.port;
+ 	    set_veil_msg( &vmsg, VEIL_MSG_DATA_NOTIFY,
+ 	                  src_ip, src_port, dest_ip, dest_port );
+ 	    set_veil_msg_data_notify( &vmsg.msg.dntfy, nbytes );
+ 	    vmsg.rti_data.TimeStamp = now;
+ 	    forward_veil_msg( &vmsg, latency.ldata_notify );
+ 	}
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::resume( void )
+ {
+ 	cout << "@ " << Scheduler::instance().clock() << " ";
+ 	cout << name_ << ": LiveApplication::resume()" << endl;
+ 	ASSERT( awaiting_resume, ("") );
+ 	awaiting_resume = false;
+ 	if( tosend.bytes > 0 )
+ 	{
+ 	    int n = tosend.bytes;
+ 	    tosend.bytes = 0;
+             awaiting_resume = true;
+ 	    Application::send( n );
+ cout << name_ << ": resume() sent " << n << endl;
+ 	}
+ 
+ 	if( nomore_data )
+ 	{
+ cout << name_ << ": resume-stopping" << endl;
+ 	    stop();
+ cout << name_ << ": resume-stopped" << endl;
+ 	}
+ cout << name_ << ": Done resume" << endl;
+ }
+ 
+ /*---------------------------------------------------------------------------*/
+ void LiveApplication::disconnect( void )
+ {
+ 	cout << "@ " << Scheduler::instance().clock() << " ";
+ 	cout << name_ << ": " << "LiveApplication::disconnect()" << endl;
+ 	nomore_data = true;
+ 	stop();
+ }
+ 
+ /*---------------------------------------------------------------------------*/
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/liveapp.h pdns-ia64/ns-allinone-2.27/ns-2.27/rti/liveapp.h
*** new_p/ns-allinone-2.27/ns-2.27/rti/liveapp.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/liveapp.h	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,36 ----
+ /*
+  *  Support for routing live application traffic via ns
+  *    - Kalyan Perumalla <http:/www.cc.gatech.edu/~kalyan> 15 June 2001
+  */
+ 
+ #ifndef ns_liveapp_h
+ #define ns_liveapp_h
+ 
+ #include "app.h"
+ 
+ class LiveApplication : public Application {
+ public:
+ 	LiveApplication( long addr, long port );
+ 	virtual void send(int nbytes);
+ 	virtual void recv(int nbytes);
+ 	virtual void resume( void );
+ 	virtual void initiate_connect( void );
+ 	virtual void disconnect( void );
+ 	virtual void bind_local( long port );
+ 	virtual void unbind_local( void );
+ 	virtual void bind_peer( long addr, long port );
+ 
+ protected:
+ 	virtual int command(int argc, const char*const* argv);
+ 	virtual void start();
+ 	virtual void stop();
+ 
+ protected:
+ 	struct { long addr, port; } local, peer;
+ 	struct { long bytes; } sent, recd, tosend;
+ 	bool awaiting_resume;
+ public:
+ 	bool nomore_data;
+ };
+ 
+ #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rticompress.cc pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rticompress.cc
*** new_p/ns-allinone-2.27/ns-2.27/rti/rticompress.cc	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rticompress.cc	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,164 ----
+ // Event message compression for RTI events
+ // Since NS messages are about 1700 bytes, most of which are zero
+ // this code compresses out the zeros for events being sent over the net.
+ // George F. Riley, Georgia Tech, Spring 2000
+ 
+ #include <stdio.h>
+ 
+ int Compress(unsigned long* plTarget, unsigned long* plSource, int Count)
+ { // Returns total size of target buffer
+   // This code works only on buffers <= 0x10000 words long (about 250k bytes)
+   // Target buffer must be 1 word longer than source, to allow for the
+   // case where no zeros at all occur.
+ unsigned int *pTarget=(unsigned int*)plTarget, *pSource=(unsigned int*)plSource; //KALYAN
+  int offset = 0;
+  int skipping = 1;
+  int targoffset = 0;
+  int lth;
+ 
+ if(0){fflush(stdout);fflush(stderr);printf("Compress started count=%d\n",Count);fflush(stdout);}//KALYAN
+  unsigned int/*KALYAN long*/ * pCW = pTarget; // Control word pointer
+  // Format of control word is 16 bits of length, 16 bits of starting offset
+  *pCW = 0;  // All zero CW means done
+  while(offset < Count)
+    {
+      if (skipping)
+        {
+          if (pSource[offset] |= 0)
+            { // Time to stop skipping
+              skipping = 0;
+              pCW = &pTarget[targoffset];
+              *pCW = offset; // Set source offset, leave lth zero for now
+              targoffset++;  // Leave room for CW
+              lth = 0;       // Counts how many non-zero
+            }
+          else
+            { // Still zero, just skip it
+              offset++;
+            }
+        }
+      if (!skipping)
+        {
+          // First see if we found a zero
+          if (pSource[offset] == 0)
+            { // Found a zero, but just use it unless two in a row
+              if ((offset+1) < Count)
+                {
+                  if (pSource[offset+1] == 0)
+                    {
+                      skipping = 1; // Found two in a row, resume skipping
+                      *pCW |= (lth << 16);
+                      //*pCW |= (0x1L << 31); // just for debugging, mark cw
+                      offset++; // And skip this one
+                    }
+                }
+            }
+        }
+      if (!skipping)
+        {
+          pTarget[targoffset++] = pSource[offset++];
+          lth++;
+        }
+    }
+  if (!skipping)
+    { // Need to update last CW
+      *pCW |= (lth << 16);
+      //*pCW |= (0x1L << 31); // just for debugging, mark cw
+    }
+ if(0){fflush(stdout);fflush(stderr);printf("Compress done\n");fflush(stdout);}//KALYAN
+  return(targoffset);
+ }
+ 
+ int Uncompress(unsigned long* plTarget, unsigned long* plSource, int Count)
+ { // Reverse above compression
+   // Target buffer MUST BE ZERO on entry!
+ unsigned int *pTarget=(unsigned int*)plTarget, *pSource=(unsigned int*)plSource; //KALYAN
+ int offset = 0;
+ int targoffset = 0;
+ int lth;
+ if(0){fflush(stdout);fflush(stderr);printf("Uncompress started count=%d\n",Count);fflush(stdout);}//KALYAN
+ 
+   while(offset < Count)
+     {
+       // Get next control word
+       targoffset = pSource[offset] & 0xffff;
+       lth = pSource[offset] >> 16;
+       offset++;
+       for (int i = 0; i < lth; i++)
+         { // Copy to target
+           pTarget[targoffset++] = pSource[offset++];
+         }
+     }
+ if(0){fflush(stdout);fflush(stderr);printf("Uncompress done\n");fflush(stdout);}//KALYAN
+   return(targoffset); // Last non-zero entry
+ }
+ 
+ #ifdef TEST_COMPRESS
+ 
+ #include <stdlib.h>
+ 
+ int main(int argc, char** argv)
+ {
+ unsigned long d[100];
+ unsigned long t[101];
+ unsigned long r[100];
+ 
+ int i;
+ int j;
+ int testcase = 1;
+ 
+   for (i = 0; i < 100; i++) d[i] = 0;
+   for (i = 0; i < 100; i++) r[i] = 0;
+   if (argc > 1)
+     {
+       testcase = atol(argv[1]);
+     }
+   switch (testcase) {
+   case 1 :
+     for (i = 50; i < 100; i++) d[i] = i;
+     break;
+   case 2 :
+     for (i = 20; i < 100; i+= 20)
+       {
+         for (j  = 0; j < 10; j++) d[i+j] = i + j;
+       }
+     break;
+   case 3 :
+     for (i = 20; i < 100; i+= 20)
+       {
+         for (j  = 0; j < 10; j++) d[i+j] = i + j;
+       } 
+     break;
+   case 4 :
+     for (i = 20; i < 100; i+= 20)
+       {
+         for (j  = 0; j < 10; j++) d[i+j] = i + j;
+       }
+     break;
+   case 5 :
+     for (i = 0; i < 100; i += 2) d[i] = i;
+     break;
+   case 6 :
+     for (i = 0; i < 100; i++) d[i] = i+1;
+     break;
+   case 7 :
+     for (i = 0; i < 50; i++) d[i] = i+1;
+     break;
+   }
+   j = Compress(t, d, 100);
+   printf("j %d\n", j);
+   for (i = 0; i < j; i++) printf("Targ %d %08lx\n", i, t[i]);
+   j = Uncompress(r, t, j);
+   for (i = 0; i < 100; i++)
+     {
+       if (d[i] != r[i])
+         {
+           printf("Data mismatch offs %d, act %ld exp %ld\n",
+                  i, r[i], d[i]);
+           exit(1);
+ 
+         }
+     }
+   printf("Validated ok\n");
+ }
+ #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rticompress.h pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rticompress.h
*** new_p/ns-allinone-2.27/ns-2.27/rti/rticompress.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rticompress.h	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,12 ----
+ // Event message compression for RTI events
+ // Since NS messages are about 1700 bytes, most of which are zero
+ // this code compresses out the zeros for events being sent over the net.
+ // George F. Riley, Georgia Tech, Spring 2000
+ 
+ #ifndef __RTICOMPRESS_H__
+ #define __RTICOMPRESS_H__
+ 
+ int Compress(unsigned long* pTarget, unsigned long* pSource, int Count);
+ int Uncompress(unsigned long* pTarget, unsigned long* pSource, int Count);
+ 
+ #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rtidummy.cc pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtidummy.cc
*** new_p/ns-allinone-2.27/ns-2.27/rti/rtidummy.cc	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtidummy.cc	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,63 ----
+ // Dummy classes so the "non-rti" ns will still run
+ // (The tcl init code references RTI classes so we need this)
+ // George F. Riley. Georgia Tech.
+ // Fall 1998
+ 
+ 
+ //#include <stdlib.h>
+ //#include <string.h>
+ 
+ #include "tclcl.h"
+ #include "packet.h"
+ #include "ip.h"
+ #include "agent.h"
+ #include "scheduler.h"
+ #include "delay.h"
+ 
+ class RTILink : public LinkDelay {
+   public :
+     RTILink();
+     int command(int, const char*const*);
+ };
+ 
+ class RTIRouter : public Agent {
+   public :
+     RTIRouter();
+     int command(int, const char*const*);
+ };
+ 
+ static class RTILinkClass : public TclClass {
+  public:
+ 	RTILinkClass() : TclClass("RTILink") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new RTILink());
+ 	}
+ } class_RTI_link;
+ 
+ static class RTIRouterClass : public TclClass {
+  public:
+ 	RTIRouterClass() : TclClass("Agent/RTIRouter") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new RTIRouter());
+ 	}
+ } class_RTI_agent;
+ 
+ RTILink::RTILink() : LinkDelay()
+ {
+ }
+ 
+ int RTILink::command(int argc, const char*const* argv)
+ {
+   return (LinkDelay::command(argc, argv));
+ }
+ 
+ RTIRouter::RTIRouter() : Agent(/*XXX*/PT_MESSAGE)
+ {
+ 
+ }
+ 
+ int RTIRouter::command(int argc, const char*const* argv)
+ {
+   return (Agent::command(argc, argv));
+ }
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rtilink.cc pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtilink.cc
*** new_p/ns-allinone-2.27/ns-2.27/rti/rtilink.cc	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtilink.cc	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,350 ----
+ // New link type by George Riley.  Used to allow running ns simulations in 
+ // parallel.  Lets a simulation on one system be broken into several
+ // simulations on several systems
+ // The RTILink is a link where only one end is present on this simulation.
+ // The other end of the link is on another simulation somewhere.  The
+ // packet received is forwarded to the appropriate simulation via RTIKit
+ // with the timestamp incremented by the appropriate delay.
+ // George F. Riley. Georgia Tech.
+ // Fall 1998
+ 
+ // libSynk/libbrti includes
+ extern "C" {
+ #include "brti.h"
+ }
+ 
+ //#define USE_BACKPLANE
+ //#undef  USE_BACKPLANE
+ #ifdef  USE_BACKPLANE
+ #include "backplane/dsim.h"
+ #endif
+ 
+ //#include <stdlib.h>
+ //#include <string.h>
+ 
+ #include "tclcl.h"
+ //#include "net.h"
+ #include "packet.h"
+ #include "ip.h"
+ #include "rti/hdr_rti.h"
+ #include "agent.h"
+ #include "scheduler.h"
+ 
+ #include "rti/rtilink.h"
+ #ifdef USE_COMPRESSION
+ #include "rti/rticompress.h"
+ #endif
+ 
+ /* ALFRED - pkt count stats */
+ #include "common/pktcount.h"
+ 
+ extern char          hn[255];       /* Host name (RTISCHED.CC) */
+ 
+ RTILink::FreeVec_t RTILink::FreeVec;
+ 
+ static class RTILinkClass : public TclClass {
+  public:
+ 	RTILinkClass() : TclClass("RTILink") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new RTILink());
+ 	}
+ } class_RTI_link;
+ 
+ // Static "WhereMessage" procedure
+ char* RTILink::WhereMessage (   /* Advise where to store Rx message */
+     long         MsgSize,        /* Size of RX Message */
+     void*        pvRouter,       /* Context info */
+     long         MsgType)        /* Type specified by sender */
+ {
+ char* buf;
+ RTIRouter *pRouter = (RTIRouter *)pvRouter;
+ RTIRouter** ppContext;
+ 
+  if(0)printf("WhereMsg size %ld Type %ld context %p\n",
+          MsgSize, MsgType, pRouter);
+  if (FreeVec.size())
+    { // entries exist in free vector
+      // ALFRED fix possible buffer overflow by reallocating memory as needed
+      buf = FreeVec.back();
+      buf -= sizeof(long)/sizeof(char); // Go back one long to find zone size
+      if(0)printf("Reusing msg %p\n", buf);
+      FreeVec.pop_back(); // Remove it
+      if (*((long *)buf) < MsgSize) {
+        char *tbuf;
+        long x = (MsgSize / sizeof(long) + sizeof(long)) * sizeof(long);
+        if(0){printf("buf entry too small, reallocating memory from %d to %d\n", 
+            *((long *)buf), MsgSize);fflush(stdout);}
+        if ((tbuf = (char *)realloc(buf, x)) == NULL) {
+          printf("Error: RTILink::WhereMessage, realloc() failed!\n");
+          exit(1);
+        }
+        buf = tbuf;
+        long *tmp = (long *)buf;
+        *tmp = (long)MsgSize;
+      }  
+    }
+  else
+    {
+      long x = (MsgSize / sizeof(long) + sizeof(long)) * sizeof(long);
+      if ((buf = (char *)malloc(x)) == NULL) {
+        printf("Error: RTILink::WhereMessage, malloc() failed!\n");
+        exit(1);
+      }
+      long *tmp = (long *)buf;
+      *tmp = (long)MsgSize;
+      if(0)printf("Allocating new buf, size %d, ptr %p\n", MsgSize, buf);
+    }
+  if (buf == NULL)
+    {
+      printf("Error: buf is NULL...? Fatal error.\n");
+      exit(1);
+    }
+ 
+  char *tmp = buf + sizeof(long)/sizeof(char); // Need to offset by long
+  ppContext = (RTIRouter**)&tmp[MsgSize];
+  *ppContext = pRouter; /* Set context after message */
+  if(0){printf("RTILink setting pRouter %p msgtype %d\n", pRouter, 
+      MsgType);fflush(stdout);}
+  return(tmp);
+ }
+ 
+ void RTILink::FreeMessage(
+     char*         pMsg)
+ {
+   if(0)printf("Freeing Msg %p\n", pMsg);
+   FreeVec.push_back(pMsg);
+ }
+ 
+ RTILink::RTILink() : LinkDelay()
+ {
+  if(0)printf("Hello from RTILINK CC constructor\n");
+  // Track the tcl "rtarget_" variable
+  rtarget_ = NULL;
+ 
+  bind_bw("bandwidth_", &bandwidth_);
+  bind_time("delay_", &delay_);
+  bind("off_ip_",               &off_ip_);
+ }
+ 
+ int RTILink::command(int argc, const char*const* argv)
+ {
+   //NsObject*  pHead;
+ //ipaddr_t   ipaddr;
+ int i;
+ 
+ //Tcl& tcl = Tcl::instance();
+   if(0){printf("RTILink Command %d ", argc);
+     for(i=0;i<argc;i++)printf("%d - %s ", i, argv[i]);printf("\n");
+     fflush(stdout);}
+   if (argc == 3) 
+     {
+       if (strcmp(argv[1], "set-target") == 0)
+         {
+           rtarget_ = (NsObject*)TclObject::lookup(argv[2]);
+           if (rtarget_ == NULL)
+             {
+               printf("remote target %s not found\n", argv[2]);
+               exit(1);
+             }
+           return(TCL_OK);
+         }
+     }
+   if (argc == 5) 
+     {
+       if (strcmp(argv[1], "create-group") == 0)
+         {
+           //printf("%s create-group %s %s %s\n", name(), argv[2], argv[3], argv[4]);
+           CreateGroup(argv[2], argv[3], argv[4]);
+           return(TCL_OK);
+         }
+       if (strcmp(argv[1], "publish-group") == 0)
+         {
+           //printf("%s publish-group %s %s %s\n", name(), argv[2], argv[3], argv[4]);
+           PublishGroup(argv[2], argv[3], argv[4]);
+           return(TCL_OK);
+         }
+       if (strcmp(argv[1], "join-group") == 0)
+         {
+           //printf("%s join-group %s %s %s\n", name(), argv[2], argv[3], argv[4]);
+           JoinGroup(argv[2], argv[3], argv[4]);
+           return(TCL_OK);
+         }
+     }
+   return (LinkDelay::command(argc, argv));
+ }
+ 
+ extern unsigned long FM_nodeid;
+ static int firstpass = 0; // debug
+ void RTILink::recv(Packet* p, Handler* h)
+ {
+   //int r;
+ double txtime;
+ struct MsgS*   pMyMsg;
+ //char   mybuf[Packet::hdrlen_ + sizeof(struct MsgS) + 16];
+ static char* mybuf = NULL;  // Buffer for the "reflected" message
+ long*  pMsgType;
+ char*  pMyData;
+ #ifdef USE_BACKPLANE
+ static isize_t bufsize = 0;
+ isize_t ol = 0;
+ #define FUDGE 1016
+ #endif
+ 
+ #ifdef USE_COMPRESSION
+ int    compressedlth;
+ #endif
+ 
+   hdr_cmn* hdr = hdr_cmn::access(p);
+   hdr_ip*  ip  = hdr_ip::access(p);
+   hdr_rti* rti = hdr_rti::access(p);
+   txtime = hdr->size() * 8.0 / bandwidth_;
+ 
+   if (ip->dport() < 0) printf("Sending dport %d\n", ip->dport());
+   if (!mybuf)
+     { // First time, allocate the message buffer
+ #ifdef USE_BACKPLANE
+       bufsize = InquireMessageSize(/*KALYAN:GetDSimHandle()*/);
+       mybuf = new char[bufsize + sizeof(struct MsgS) + FUDGE]; // Fudge a bit
+ #else
+       mybuf = new char[Packet::hdrlen_ + sizeof(struct MsgS) + 16];
+ #endif
+     }
+   pMyMsg = (struct MsgS*)mybuf;
+   pMsgType = (long*)&pMyMsg[1];
+   pMyData = (char*)&pMsgType[1];
+   pMyMsg->TimeStamp = Scheduler::instance().clock() + txtime + delay_;
+   *pMsgType = RTIKIT_nodeid;//KALYAN: 0;
+   if(0)printf("RTILink forwarding to dstip %08x dstport %d\n",
+          rti->ipdst(), rti->ipdstport());
+   /* Use the nodeid as msgtype, so we can ignore our own messages */
+   /* Above does not work!  Put nodeid in ip header! (HACK)! */
+   rti->RTINodeId() = RTIKIT_nodeid;
+ #ifdef USE_BACKPLANE
+   ol = bufsize + FUDGE;
+   ExportMessage((char*)p,
+                 NULL, 0,
+                 pMyData, (int*)&ol);
+                 
+   RTI_UpdateAttributeValues(ObjInstance, pMyMsg,
+                             MSGS_SIZE(ol/*KALYAN*/+sizeof(int)),
+                             0);
+ 	rlinkPktC++;
+ #else
+   /* Copy entire packet to the payload */
+ #ifdef USE_COMPRESSION
+   // Use compression!
+   compressedlth = Compress((unsigned long*)pMyData,
+                            (unsigned long*)p->bits(), 
+                            (Packet::hdrlen_ + 3) / 4);
+   RTI_UpdateAttributeValues(ObjInstance, pMyMsg,
+                             MSGS_SIZE(compressedlth * 4 + sizeof(int)),
+                             // RTIKIT_nodeid);
+                             0);
+ 	rlinkPktC++;
+ #else
+ #ifdef DEBUG
+ hdr_rti* hrti = hdr_rti::access(p);
+ printf("RTILink::Update srcip %08x srcdst %d dstip %08x dstport %d\n",
+ hrti->ipsrc(), hrti->ipsrcport(),
+ hrti->ipdst(), hrti->ipdstport());
+ #endif
+   memcpy(pMyData, p->bits(), Packet::hdrlen_);
+   RTI_UpdateAttributeValues(ObjInstance, pMyMsg,
+                             MSGS_SIZE(Packet::hdrlen_ + sizeof(int)),
+                             // RTIKIT_nodeid);
+                             0);
+ 	rlinkPktC++;
+ #endif
+ #endif
+ 
+   // Also schedule event when link tx complete
+   Scheduler& s = Scheduler::instance();
+   s.schedule(h, &intr_, txtime); // Notify when done
+   // And free the packet we got
+   Packet::free(p);
+ }
+ 
+ void RTILink::CreateGroup( // Create the RTI group for this link
+     const char* pRouter,
+     const char* pBroadcastAddr,
+     const char* pIPAddr)
+ {
+ char          BroadcastAddr[128];
+ unsigned long ipaddr;
+ unsigned long bcastaddr;
+ char          work[255];
+ 
+   ipaddr = atol(pIPAddr);
+   sprintf(work, "%ld.%ld.%ld.%ld",
+           ((ipaddr >> 24) & 0xff),
+           ((ipaddr >> 16) & 0xff),
+           ((ipaddr >>  8) & 0xff),
+           ((ipaddr >>  0) & 0xff));
+   if(1)printf("%s CreateGroup ipaddr %s\n", hn, work);
+ 
+   strcpy(BroadcastAddr, pBroadcastAddr);
+   bcastaddr = atol(pBroadcastAddr);
+   sprintf(work, "%ld.%ld.%ld.%ld",
+           ((bcastaddr >> 24) & 0xff),
+           ((bcastaddr >> 16) & 0xff),
+           ((bcastaddr >>  8) & 0xff),
+           ((bcastaddr >>  0) & 0xff));
+   if ((ipaddr & 0xff) == 0x01)
+     {
+       // Create the class (use broadcast address for group name)
+       // May already exst (could be created by peer on other system)
+       RTI_CreateClass(work);
+       if(1)printf("%s created objclass for %s\n", hn, work);
+     }
+ }
+ 
+ void RTILink::PublishGroup( // Publish the RTI group for this link
+     const char* pRouter,
+     const char* pBroadcastAddr,
+     const char* pIPAddr)
+ {
+ char          BroadcastAddr[128];
+ unsigned long ipaddr;
+ unsigned long bcastaddr;
+ char          work[255];
+ 
+   ipaddr = atol(pIPAddr);
+   strcpy(BroadcastAddr, pBroadcastAddr);
+   bcastaddr = atol(pBroadcastAddr);
+   sprintf(work, "%ld.%ld.%ld.%ld",
+           ((bcastaddr >> 24) & 0xff),
+           ((bcastaddr >> 16) & 0xff),
+           ((bcastaddr >>  8) & 0xff),
+           ((bcastaddr >>  0) & 0xff));
+   ObjClass = RTI_GetObjClassHandle(work);
+   if (ObjClass == NULL)
+     {
+       printf("%s can't get objclasshandle for %s\n", hn, work);
+       exit(0);
+     }
+   // Publish and register my interest in this class
+   RTI_PublishObjClass(ObjClass);
+   ObjInstance = RTI_RegisterObjInstance(ObjClass);
+   if(1)printf("%s Registered objinst5, ObjInst %ld\n", name(), ObjInstance);
+ }
+ 
+ void RTILink::JoinGroup( // Join the RTI group for this link
+     const char* pRouter,
+     const char* pBroadcastAddr,
+     const char* pIPAddr)
+ {
+ NsObject*    pNSRouter;
+ //char         BroadcastAddr[128];
+  
+   // Get the C++ object for the associated RTIRouter 
+   pNSRouter = (NsObject*)TclObject::lookup(pRouter);
+   // Join the group
+   if (! RTI_IsClassSubscriptionInitialized (ObjClass))
+     { //  Set up a context
+       RTI_InitObjClassSubscription (ObjClass, WhereMessage, pNSRouter);
+     }
+   RTI_SubscribeObjClassAttributes(ObjClass);
+   if(1)printf("Router %s subcribed...\n", pNSRouter->name());
+ }
+ 
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rtilink.h pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtilink.h
*** new_p/ns-allinone-2.27/ns-2.27/rti/rtilink.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtilink.h	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,38 ----
+ // Definition of RTILink
+ // Used for distributed ns simulations
+ // George F. Riley, Georgia Tech, Fall 1998
+ 
+ #ifndef __RTILINK_H__
+ #define __RTILINK_H__
+ 
+ #include <vector>
+ 
+ #include "delay.h"
+ #include "rtirouter.h"
+ 
+ class RTILink : public LinkDelay {
+   public :
+     RTILink();
+     void recv(Packet* p, Handler*);  // Receive from local system
+     int command(int, const char*const*);
+   private :
+     NsObject* rtarget_;  // DEBUG! local target
+     double bandwidth_;	 /* bandwidth of underlying link (bits/sec) */
+     double delay_;	 /* line latency */
+     Event intr_;
+     RTI_ObjClassDesignator    ObjClass;     /* Class for messages from peers */
+     RTI_ObjInstanceDesignator ObjInstance;  /* Instance of above */
+     int   off_ip_;
+     // Private functions
+     void CreateGroup(const char*, const char*, const char*);
+     void PublishGroup(const char*, const char*, const char*);
+     void JoinGroup(const char*, const char*, const char*);
+ public:
+     // Define the wheremessage callback
+     static char* WhereMessage( long, void*, long);
+     static void  FreeMessage(char*);
+     typedef vector<char*> FreeVec_t;
+     static  FreeVec_t FreeVec;
+ };
+ #endif
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rtioob.h pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtioob.h
*** new_p/ns-allinone-2.27/ns-2.27/rti/rtioob.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtioob.h	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,38 ----
+ // Out-of-Band message for PDNS
+ // Allows one ns to communicate useful info to a second instance
+ // George F. Riley, Georgia Tech, Winter 2000
+ 
+ #include <rti/hdr_rti.h>
+ 
+ typedef enum {
+   RTIM_LoadNewAgent,  // Request a new agent be loaded
+   RTIM_UnloadAgent,   // Unload an existing agent
+   RTIM_SetDestPort    // Set destination port for an agent
+   // Will need more as time goes on
+ } RTIMsgEnum_t;
+ 
+ typedef struct {
+   RTIMsgEnum_t  t;     // Type of messgae
+   ipaddr_t      da;    // Specified dest address
+   ipportaddr_t  dp;    // Dest port
+   ipaddr_t      sa;    // Specified src address
+   ipportaddr_t  sp;    // Src port
+   unsigned long ep1;   // Extra parameter 1
+   unsigned long ep2;   // Extra parameter 2
+   unsigned long ep3;   // Extra parameter 3
+   unsigned long ep4;   // Extra parameter 4
+   // Will need more
+ } RTIMsg_t;
+ 
+ void SendOOB(int t, int da, int dp, int sa, int sp); // See rtisched.cc
+ 
+ #ifdef HAVE_FILTER
+ 
+ void SendOOBFilter(int t);
+ 
+ typedef enum {
+   RTIFilterStart,  // Request to start filtering
+   RTIFilterStop    //Request to stop filtering
+ } RTIFilterEnum_t;
+ 
+ #endif /*HAVE_FILTER*/
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rtirouter.cc pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtirouter.cc
*** new_p/ns-allinone-2.27/ns-2.27/rti/rtirouter.cc	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtirouter.cc	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,682 ----
+ // New agent by George Riley.  Used to allow running ns simulations in 
+ // parallel.  Lets a simulation on one system be broken into several
+ // simulations on several systems
+ 
+ // George F. Riley. Georgia Tech.
+ // Fall 1998
+ 
+ #include <sys/socket.h>
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
+ 
+ #include "tclcl.h"
+ #include "packet.h"
+ #include "ip.h"
+ #include "rti/hdr_rti.h"
+ #include "agent.h"
+ #include "scheduler.h"
+ 
+ #include <map>
+ 
+ #define USE_NIX
+ #ifdef USE_NIX
+ #include "nix/hdr_nv.h"
+ #include "nix/nixnode.h"
+ #endif
+ 
+ #include "rti/rtirouter.h"
+ #include "rti/rtioob.h"
+ 
+ // ALFRED - add node manip support
+ #include "node.h"
+ 
+ // Defines for passthrough routing management
+ // RouteMap is destination IP/PTROute_t*
+ // ALFRED change map to multimap due to source-based
+ typedef multimap<ipaddr_t, PTRoute_t*> PTRouteMap_t;
+ typedef PTRouteMap_t::iterator    PTRouteMap_it;
+ typedef PTRouteMap_t::value_type  PTRouteMap_pt;
+ 
+ static PTRouteMap_t ptRoutes; // Map of passthrough routes
+ 
+ extern char         hn[255]; /* Hostname, defined in rtisched1.cc */
+ #define RTIKIT_nodeid FM_nodeid
+ extern unsigned long FM_nodeid;
+ 
+ // Prototypes in rtisched.cc
+ NsObject* GetLocalIP(ipaddr_t ipaddr);
+ Agent *GetIPRoute(ipaddr_t ipaddr, ipaddr_t srcip);
+ 
+ static class RTIRouterClass : public TclClass {
+  public:
+ 	RTIRouterClass() : TclClass("Agent/RTIRouter") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new RTIRouter());
+ 	}
+ } class_RTI_agent;
+ 
+ static double Now()
+ { // debug
+   return Scheduler::instance().clock();
+ }
+ 
+ RTIRouter::RTIRouter() : Agent(/*XXX*/PT_MESSAGE)
+ {
+  rTable_  = NULL;
+  rTableSize_   = 0; // No routes yet
+  rTableLength_ = 0; // No routes yet
+  pDefaultRemoteRoute = NULL;
+ }
+ 
+ RTIRouter::~RTIRouter() 
+ {
+ }
+ 
+ int RTIRouter::command(int argc, const char*const* argv)
+ {
+ NsObject*  pHead;
+ ipaddr_t   ipaddr;
+ ipaddr_t   targmask;
+ 
+   if(0){printf("RTIRouter command cnt %d ", argc);
+     for(int i=0;i<argc;i++)printf("%d - %s ", i, argv[i]);printf("\n");}
+   if (argc == 3) 
+     {
+       if (strcmp(argv[1], "add-default-remote-route") == 0)
+         {
+           pHead = (NsObject*)TclObject::lookup(argv[2]);
+           if (pHead == NULL)
+             {
+               printf("ADRR - remote target %s not found\n", argv[2]);
+               exit(1);
+             }
+           SetDefaultRemoteRoute(pHead);
+           return(TCL_OK);
+         }
+     }
+   // ALFRED modify add-route for source-based support
+   if (argc == 7) {
+     if (strcmp(argv[1], "add-route") == 0) {
+       struct in_addr addr;
+       ipaddr_t srcip, smask;
+       if (strchr(argv[4], '.') != NULL) { // Dotted notation
+         inet_aton(argv[4], &addr);
+         ipaddr = ntohl(addr.s_addr);
+       } else {
+         ipaddr = strtol(argv[4], NULL, 0);
+       }
+       if (strchr(argv[2], '.') != NULL) { // Dotted notation
+         inet_aton(argv[2], &addr);
+         srcip = ntohl(addr.s_addr);
+       } else {
+         srcip = strtol(argv[2], NULL, 0);
+       }
+       smask = atol(argv[3]);
+       targmask = atol(argv[5]);
+       pHead = (NsObject*)TclObject::lookup(argv[6]);
+       if(0)printf("Adding route %s %s %s %s\n", argv[2], argv[3], 
+           argv[4], argv[5]);
+       if (pHead == NULL) {
+         printf("add-route cannot find object %s\n", argv[6]);
+         exit(1);
+       }
+       AddRoute(ipaddr, pHead, targmask, srcip, smask);
+       return(TCL_OK);
+     }
+     if (strcmp(argv[1], "add-route-passthrough") == 0) {
+       ipaddr_t srcip, smask, rlinkip;
+       struct in_addr addr;
+       if (strchr(argv[2], '.') != NULL) { // Dotted notation
+         inet_aton(argv[2], &addr);
+         ipaddr = ntohl(addr.s_addr);
+       } else {
+         ipaddr = strtol(argv[2], NULL, 0);
+       }
+       if (strchr(argv[3], '.') != NULL) { // Dotted notation
+         inet_aton(argv[3], &addr);
+         targmask = ntohl(addr.s_addr);
+       } else {
+         targmask = strtol(argv[3], NULL, 0);
+       }
+       if (strchr(argv[4], '.') != NULL) { // Dotted notation
+         inet_aton(argv[4], &addr);
+         srcip = ntohl(addr.s_addr);
+       } else {
+         srcip = strtol(argv[4], NULL, 0);
+       }
+       if (strchr(argv[5], '.') != NULL) { // Dotted notation
+         inet_aton(argv[5], &addr);
+         smask = ntohl(addr.s_addr);
+       } else {
+         smask = strtol(argv[5], NULL, 0);
+       }
+       if (strchr(argv[6], '.') != NULL) { // Dotted notation
+         inet_aton(argv[6], &addr);
+         rlinkip = ntohl(addr.s_addr);
+       } else {
+         rlinkip = strtol(argv[4], NULL, 0);
+       }
+       if(0)printf("%s cmd %s %s %s %s\n",
+                       name(), argv[1], argv[2], argv[3], argv[4]);
+       if(0)printf("addroute-pt dstip %08x mask %08x rlinkip %08x\n",
+                       ipaddr, targmask, rlinkip);
+       AddPTRoute(ipaddr, targmask, rlinkip, srcip, smask);
+       return(TCL_OK);
+     }
+   }
+   return (Agent::command(argc, argv));
+ }
+ 
+ void RTIRouter::recv(Packet* p, Handler* h)
+ {
+ 
+   NsObject *pHead, *pNode;
+   hdr_rti *rti = hdr_rti::access(p);
+   
+   if(0)printf("%s RTIRouter::recv at %-8.5f, srcip %08x, dst %08x:%d\n", 
+       name_, Now(), rti->ipsrc(), rti->ipdst(), rti->ipdstport());
+   // ALFRED fixed this with GetLocalIP()
+   if (rti->ipdst() != 0 && rti->ipdstport() != -1) { 
+     pNode = GetLocalIP(rti->ipdst());
+     if (pNode == NULL) { 
+       // Not a local address, forward to another sysetm via rti
+       if(0)printf("%s Forwarding non-local packet to %s\n", name(), \
+           target_->name());
+       // ALFRED add src for Lookup below
+       pHead = Lookup(rti->ipdst(), rti->ipsrc());
+       if (pHead == NULL) {
+         printf("FATAL: %s no route to %08x\n", name(), rti->ipdst());
+         exit(0);
+       }
+       // Forward it on to the ttl-queue-rlink chain
+       if(0)printf("%s routing dst %08x to %s\n", name(), \
+           rti->ipdst(), pHead->name());
+       pHead->recv(p, h);
+     } else {
+       // First check if we have a local->remote->local situation
+       Agent *tmp = GetIPRoute(rti->ipdst(), rti->ipsrc());
+       if (tmp == NULL) {
+         rrecv(p, h);
+       } else {
+         // local->remote->local fix
+         pHead = Lookup(rti->ipdst(), rti->ipsrc());
+         if (pHead == NULL) {
+           printf("FATAL: %s no route to %08x\n", name(), rti->ipdst());
+           exit(0);
+         }
+         pHead->recv(p, h);
+       }
+     }
+   } else {
+     rrecv(p, h);
+   }
+ }
+ 
+ static ipportaddr_t TryToCreate(ipaddr_t ipaddr, ipaddr_t daddr,
+                                 ipportaddr_t dport, int instid,
+                                 unsigned long ep1, unsigned long ep2)
+ {
+ Tcl& tcl = Tcl::instance();
+ static int firstpass = 1;
+ static int exists = 0;
+ int r;
+ int port = 0;
+ 
+  if (firstpass) 
+    { // See if the create-and-bind proc exists
+      tcl.evalf("lsearch -exact [info procs] create-and-bind");
+      tcl.resultAs(&r);
+      if (r >= 0)
+        { // Ok found it
+          if(0)printf("create-and-bind exists\n");
+          exists = 1;
+        }
+      else
+        { // No create-and-bind, just ignore
+          if(0)printf("create-and-bind NOT FOUND\n");
+        }
+      firstpass = 0;
+    }
+  if (exists)
+    {
+      tcl.evalf("create-and-bind 0x%08x 0x%08x %d %d %d",
+                ipaddr, daddr, dport, ep1, ep2);
+      tcl.resultAs(&port);
+      if(0)printf("The bound port is %d\n", port);
+    }
+  return port;
+ }
+ 
+ static ipportaddr_t FindDest(ipaddr_t ipaddr, ipaddr_t daddr,
+                                 ipportaddr_t dport)
+ { // On local node ipaddr, find agent with dest addr/port specified,
+   // return src port
+ ipportaddr_t port = -1;
+ char     work[255];
+ 
+   NsObject* pNode = GetLocalIP(ipaddr);
+   if (pNode)
+     { // Node is found, now find the agent (in tcl)
+       Tcl& tcl = Tcl::instance();
+       sprintf(work, "0x%08x", daddr);
+       tcl.evalf("%s find-srcport %s %d", pNode->name(), work, dport);
+       tcl.resultAs((int*)&port);
+     }
+   return port;
+ }
+ 
+ void SendOOB(int t, int da, int dp, int sa, int sp,
+              unsigned long ep1, unsigned long ep2,
+              unsigned long ep3, unsigned long ep4); // See rtisched.cc
+ 
+ void RTIRouter::rrecv(Packet* p, Handler*)
+ {
+ int           r;
+ ipaddr_t      ipaddr;
+ ipportaddr_t  dport, newdport;
+ NCVal_t       Cache;
+ char*         pRes;
+ int           nodeid;
+ int           portid;
+ int           IntID;
+ char          nsnodename[255];
+ char          nsagentname[255];
+ bool          no_cache = false; // ALFRED
+ Tcl&          tcl = Tcl::instance();
+ 
+   hdr_rti*  rti = hdr_rti::access(p);
+   hdr_ip*   ip =  hdr_ip::access(p);
+   hdr_cmn*  hc =  hdr_cmn::access(p);
+ 
+   if(0)printf("%s RTIRouter::rrecv at %-8.5f, srcip %08x, dst %08x:%d\n", 
+       name_, Now(), rti->ipsrc(), rti->ipdst(), rti->ipdstport());
+   if (rti->RTINodeId() == RTIKIT_nodeid) {
+     if(0)printf("rrecv: ignoring own packet %ld\n", RTIKIT_nodeid);
+     Packet::free(p);
+     return;
+   }
+   ipaddr = rti->ipdst();
+   dport = rti->ipdstport();
+ 
+   if(0)printf("rrecv dstip %08x dstport %d\n", ipaddr, dport);
+   if (dport == 0)
+     { // This is special case for connecting to remote agents at port 0
+       // The code will try to allocate and bind an agent to the specified
+       // ip address
+       //      dport = TryToCreate(ipaddr, rti->ipsrc(), rti->ipsrcport(),
+       //                    hc->instance_id(), 0, 0);
+       newdport = FindDest(ipaddr, rti->ipsrc(), rti->ipsrcport());
+       // Might return -1 if passthrough
+       if (newdport >= 0)
+         {
+           dport = newdport;
+           if(0)printf("Finddest found port %d\n", dport);
+           rti->ipdstport() = dport; // Use the newly creatd one
+           // And inform the originator
+           if(0)printf("SendingOOB, SetDestPort, dport %d\n", dport);
+           SendOOB(RTIM_SetDestPort, ipaddr, dport, rti->ipsrc(),
+                   rti->ipsrcport(),
+                   0, 0, 0, 0);
+         }
+     }
+   if(0)printf("%s %f: received pkt from remote, src %08x:%d dst %08x:%d\n", 
+       name(), Now(), rti->ipsrc(), rti->ipsrcport(), ipaddr, dport);
+   // Try to find in cache
+   Cache = FindCache(ipaddr, dport);
+   if (Cache.first == -1)
+     {
+       // Not in cache, lookup (slower)
+       Node *pNode = (Node*)GetLocalIP(ipaddr);
+       if (!pNode)
+         { // Can't find target ip addr, must be pass through
+           Agent* pAgent = NULL;
+           if(0)printf("Can't find targ for ip %08x, assuming passthrough\n", 
+               ipaddr);
+           // First see if we have a passthrough routing entry
+           // ALFRED always use current IP address instead source
+           //PTRoute_t* pt = GetPTRoute(ipaddr, rti->ipsrc());
+           PTRoute_t* pt = GetPTRoute(ipaddr, my_ipaddr_);
+           if (pt) { 
+             if(0)printf("Found pt route for %08x\n", ipaddr);
+             pAgent = pt->pObj;
+           } else {
+             // Look for a default
+             // ALFRED print warning message
+             printf("RTIRouter(%s): Can't find ptroute for %08x!\n", 
+                 name(), ipaddr);
+             printf("  Warning! Using unsupported default-routes!\n");
+             tcl.evalf("%s set node_", name());
+             if(0)printf("Attached node is %s\n", tcl.result());
+             tcl.evalf("%s default-route", tcl.result());
+             if(0)printf("Default route is %s\n", tcl.result());
+             pAgent = (Agent*)TclObject::lookup(tcl.result());
+           }
+           if (pAgent == NULL) {
+             printf("No agent for default route on node %s\n", name());
+             fflush(stdout);
+             Packet::free(p);
+             return;
+           }
+           // Add to cache
+           Cache = AddCache(ipaddr, dport, pAgent->addr(), pAgent->port());
+           // Redirect packet to rtirouter on default route
+           ip->daddr() = pAgent->addr();
+           ip->dport() = pAgent->port();
+           // Now forward to target      
+           if (target_ == NULL) {
+             printf("%s NO TARGET ON RRECV!\n", name());
+             return;
+           }
+           if(0)printf("Target is %s\n", target_->name());
+         }
+       else
+         { // Is local
+ 	        nodeid = pNode->nodeid();
+           if(0)printf("Node id is %d\n", nodeid);
+           tcl.evalf("%s findport %d", pNode->name(), dport);
+           strcpy(nsagentname, tcl.result());
+           if(0)printf("Target agent is %s\n", nsagentname);
+           Agent* pAgent = (Agent*)TclObject::lookup(nsagentname);
+           if (pAgent == NULL) {
+             // ALFRED instead of dropping here, forward to end host droptarget
+             //printf("No agent for port %d on node %s\n", dport, pNode->name());
+             //Packet::free(p);
+             //return;
+             tcl.evalf("%s get-droptarget", pNode->name());
+             pAgent = (Agent *)TclObject::lookup(tcl.result());
+             strcpy(nsagentname, pAgent->name());
+             // Bypass the IntID hacks below
+             tcl.evalf("%s set dst_addr_ 0", nsagentname);
+             tcl.evalf("%s set agent_port_", nsagentname);
+             tcl.resultAs(&portid);
+             if(0)printf("RTIRouter: valid node, no agent at port: connecting to droptarget(%s:%d)\n", nsagentname, portid);
+             no_cache = true;
+           } else {
+             portid = pAgent->port();
+             if(0)printf("Agent portid %d\n", portid);
+             Cache = AddCache(ipaddr, dport, nodeid, portid); // Add to cache
+           }
+           // Verify that the target has a destination
+           tcl.evalf("%s set dst_addr_", nsagentname);
+           tcl.resultAs(&IntID);
+           if(0)printf("NSAgentName %s IntId %d\n", nsagentname, IntID);
+           if (IntID < 0)
+             { // No dest on ultimate target, point back to me for reply
+               // Is this always right????
+               if(0)printf("MyAddr %08x\n", addr());
+               if(0)printf("Setting stuff ofr agent %s, daddr %d dport %d\n",
+                           nsagentname, addr(),port());
+               tcl.evalf("%s set dst_addr_ %d", nsagentname, addr());
+               tcl.evalf("%s set dst_port_ %d", nsagentname, port());
+               tcl.evalf("%s set dst_ipaddr_ %d", nsagentname, rti->ipsrc());
+               tcl.evalf("%s set dst_ipport_ %d", nsagentname, rti->ipsrcport());
+             }
+         }
+     }
+   // The the new destination, within this subnet
+   // Time to change the dest addr to the real one and fordard to target
+   if (no_cache == false) {
+     ip->daddr() = Cache.first;
+     ip->dport() = Cache.second;
+   } else {
+     ip->daddr() = nodeid;
+     ip->dport() = portid;
+   }
+   if(0)printf("%s set dstaddr to %d dport %d\n", name(), ip->daddr(), ip->dport());
+ #ifdef USE_NIX
+   // Check for NV Routing, and if so get/create a nix vector
+   nsaddr_t myid = addr();
+   hdr_nv* nv = hdr_nv::access(p);
+   NixNode* pNixNode = NixNode::GetNodeObject(myid);
+   if(0)printf("After GNO, myid %d pNix %p\n", myid, pNixNode);
+   if (pNixNode)
+     { 
+       // If we get non-null, indicates nixvector routing in use
+       // Delete any left over nv in the packet
+       // Get a nixvector to the target (may create new)
+       if(0)printf("RTI Creating NV from %ld to %ld\n",
+              myid, ip->daddr());
+       if(0)printf("Offset::rti %d Offset::nix %d\n",
+              hdr_rti::offset_, hdr_nv::offset_);
+ 
+       NixVec* pNv = pNixNode->GetNixVector(ip->daddr());
+       pNv->Reset();
+       if(0)pNv->DBDump();
+       nv->nv() = pNv; // And set  the nixvec in the packet
+       nv->h_used = 0; // And reset used portion to 0
+     }
+ #endif
+   // Now forward to target
+   if (target_ == NULL)
+     {
+       printf("%s NO TARGET ON RRECV!\n", name());
+       return;
+     }
+   if(0)printf("Target is %s\n", target_->name());
+   
+   // Deliver to the classifier for forwarding
+   target_->recv(p, (Handler*)NULL);
+ }
+ 
+ // Private member functions
+ NCVal_t RTIRouter::FindCache(
+     ipaddr_t      ipaddr,
+     ipportaddr_t  port)
+ {
+   NCMap_t::iterator i = nodeCache.find(NCKey_t(ipaddr, port));
+   if (i == nodeCache.end())
+     { // Can't find
+       NCVal_t n(-1,-1);
+       return n; // indicate not found
+     }
+   return i->second;
+ }
+ 
+ NCVal_t RTIRouter::AddCache(
+     ipaddr_t      ipaddr, 
+     ipportaddr_t  port, 
+     short         nodeid, 
+     short         portid)
+ {
+   nodeCache.insert(NCPair_t(NCKey_t(ipaddr, port), NCVal_t(nodeid, portid)));
+   return NCVal_t(nodeid, portid);
+ }
+ 
+ NsObject* RTIRouter::Lookup( // Find target for a specific ipaddr
+     ipaddr_t addr, ipaddr_t srcip)
+ {
+   int i;
+ 
+   // ALFRED first loop through check for src matches, then dst only
+   for (i = 0; i < rTableLength_; i++)
+     {
+       if(0)printf("SRC RTIRouter::Lookup %08x->%08x (%08x,%08x,%08x,%08x)\n",
+           srcip, addr, rTable_[i].srcip, rTable_[i].smask, rTable_[i].ipaddr,
+           rTable_[i].mask);
+      if (rTable_[i].srcip != 0 && rTable_[i].smask != 0) {
+       if ((rTable_[i].srcip & rTable_[i].smask) == (srcip & rTable_[i].smask)
+           && (rTable_[i].ipaddr & rTable_[i].mask) == (addr & rTable_[i].mask))
+         {
+           if(0)printf("SRC Lookup found %08x at rtable %d %08x %08x\n",
+                  addr, i, rTable_[i].ipaddr, rTable_[i].mask);
+           return(rTable_[i].pHead); // Found it
+         }
+      }
+     }
+   for (i = 0; i < rTableLength_; i++) {
+     if ((rTable_[i].ipaddr & rTable_[i].mask) == (addr & rTable_[i].mask))
+         {
+           if(0)printf("REG Lookup found %08x at rtable %d %08x %08x\n",
+                  addr, i, rTable_[i].ipaddr, rTable_[i].mask);
+           return(rTable_[i].pHead); // Found it
+         }
+   }
+   if (rTableLength_ == 0)
+     {
+       if(0)printf("Lookup no routing table\n");
+       return(pDefaultRemoteRoute); // NO route found, use default if exists
+     }
+   printf("RTIRouter(%s)::Lookup NO ROUTE found %08x->%08x!\n",
+          name(), srcip, addr);
+   // Use first as default
+   return(rTable_[0].pHead);
+ }
+ 
+ void RTIRouter::AddRoute( // Add a new route entry
+     ipaddr_t  ipaddr,     // IPAddress to add
+     NsObject* pHead,      // ns object target
+     ipaddr_t  targmask,   // Target mask for aggregation
+     ipaddr_t  srcip,      // ALFRED add srcip/smask support
+     ipaddr_t  smask)
+ {
+   if(0){printf("RTIRouter::AddRoute, rt %p rtsize %d rtlength %d\n",
+          rTable_, rTableSize_, rTableLength_);fflush(stdout);}
+   if (rTableSize_ == rTableLength_)
+     {
+       rTableSize_+=100;
+       rTable_ = (RPtr)realloc(rTable_, (rTableSize_+1)*sizeof(*rTable_));
+       if(0){printf("After realloc rTable_ %p, size\n", rTable_, rTableSize_);
+         fflush(stdout);}
+     }
+   rTable_[rTableLength_].ipaddr = ipaddr;
+   rTable_[rTableLength_].mask   = targmask;
+   rTable_[rTableLength_].pHead  = pHead;
+   // ALFRED add source to data struct
+   rTable_[rTableLength_].srcip  = srcip;
+   rTable_[rTableLength_].smask  = smask;
+   if(0)printf("%s added route to %08x via %s\n",
+               name(), ipaddr, pHead->name());
+   rTableLength_++;
+   if (pDefaultRemoteRoute == NULL) pDefaultRemoteRoute = pHead; // Set default
+ }
+ 
+ void RTIRouter::SetDefaultRemoteRoute( // Add a new route entry
+     NsObject* pHead)      // ns object target
+ {
+   if(0)printf("Set default remote route %s\n", name());
+   pDefaultRemoteRoute = pHead; // Set default
+ }
+ 
+ void RTIRouter::AddPTRoute(ipaddr_t targ, ipaddr_t mask, ipaddr_t via,
+     ipaddr_t srcip, ipaddr_t smask)
+ {
+ ipaddr_t maskedtarg = targ & mask;
+ PTRouteMap_it it;
+ 
+   if(0)printf("Adding PTRoute for targ %08x mask %08x\n", maskedtarg, mask);
+   // ALFRED Allow "dupes" due to SRC based routing
+   /*
+   // First see if existing route
+   it = ptRoutes.find(maskedtarg);
+   if (it != ptRoutes.end())
+     {
+       printf("Ignoring duplicate pt route %08x\n", maskedtarg);
+       return;
+     }
+   */
+   NsObject* pNode = GetLocalIP(via);
+   if (pNode == NULL)
+     {
+       printf("Can't find localip %08x on passthrough route, ignoring\n",
+              via);
+       return;
+     }
+   Tcl& tcl = Tcl::instance();
+   if(0)printf("Found localip %08x node %s\n", via, pNode->name());
+   tcl.evalf("%s set rtirouter_", pNode->name());
+ 
+   Agent* pRTIRouter = (Agent*)TclObject::lookup(tcl.result());
+   if (pRTIRouter == NULL)
+     {
+       printf("Can't find rtirouter on node %08x passthrough route, ignoring\n",
+              via);
+       return;
+     }
+   PTRoute_t* pt = new PTRoute_t;
+   pt->mask = mask;
+   pt->rlink = via;
+   pt->addr.addr_ = pRTIRouter->addr();
+   pt->addr.port_ = pRTIRouter->port();
+   pt->pObj = pRTIRouter;
+   // ALFRED add source stuff
+   pt->srcip = srcip;
+   pt->smask = smask;
+   ptRoutes.insert(PTRouteMap_pt(maskedtarg, pt)); // Insert the new pt route
+ }
+ 
+ PTRoute_t* RTIRouter::GetPTRoute(ipaddr_t targ, ipaddr_t srcip)
+ {
+ PTRouteMap_it it;
+ 
+   if(0)printf("entered GetPTRoute for %08x->%08x\n",srcip,targ);
+ 
+ // First see if 24 bit mask
+   it = ptRoutes.find(targ & 0xffffff00);
+   if (it != ptRoutes.end())
+     {
+       // ALFRED check src
+       PTRoute_t *tmp = it->second; // Save first entry
+       for (; it != ptRoutes.end(); it++) {
+         if (it->second->srcip != 0 && it->second->smask != 0) {
+           if ((it->second->srcip & it->second->smask) == 
+               (srcip & it->second->smask)) {
+             return it->second;
+           }
+         }
+       }
+       return tmp;
+     }
+ // Next see if 16 bit mask
+   it = ptRoutes.find(targ & 0xffff0000);
+   if (it != ptRoutes.end())
+     {
+       // ALFRED check src
+       PTRoute_t *tmp = it->second; // Save first entry
+       for (; it != ptRoutes.end(); it++) {
+         if (it->second->srcip != 0 && it->second->smask != 0) {
+           if ((it->second->srcip & it->second->smask) == 
+               (srcip & it->second->smask)) {
+             return it->second;
+           }
+         }
+       }
+       return tmp;
+     }
+ // Next see if 8 bit mask
+   it = ptRoutes.find(targ & 0xff000000);
+   if (it != ptRoutes.end())
+     {
+       // ALFRED check src
+       PTRoute_t *tmp = it->second; // Save first entry
+       for (; it != ptRoutes.end(); it++) {
+         if (it->second->srcip != 0 && it->second->smask != 0) {
+           if ((it->second->srcip & it->second->smask) == 
+               (srcip & it->second->smask)) {
+             return it->second;
+           }
+         }
+       }
+       return tmp;
+     }
+   // Try all (slower);
+   for (it = ptRoutes.begin(); it != ptRoutes.end(); it++)
+     {
+       PTRoute_t* p = it->second;
+       if (p->srcip != 0 && p->smask != 0) {
+         if ((p->srcip & p->smask) == (srcip & p->smask)) {
+           if ((targ & p->mask) == it->first) {
+             return p;
+           }
+         }
+       }
+     }
+   for (it = ptRoutes.begin(); it != ptRoutes.end(); it++) {
+     PTRoute_t *p = it->second;
+     if ((targ & p->mask) == it->first) {
+       return p;
+     }
+   }
+   return NULL; // No route found
+ }
+ 
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rtirouter.h pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtirouter.h
*** new_p/ns-allinone-2.27/ns-2.27/rti/rtirouter.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtirouter.h	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,70 ----
+ // Definition of RTIRouting agent.
+ // Used for distributed ns simulations
+ // George F. Riley, Georgia Tech, Fall 1998
+ 
+ #ifndef __RTIROUTER_H__
+ #define __RTIROUTER_H__
+ 
+ #include <object.h>
+ #include <rti/hdr_rti.h>
+ 
+ #include <map>
+ 
+ // Definitions for passthrough route map
+ typedef struct {
+   ipaddr_t     mask;      // Mask for routing info
+   ipaddr_t     rlink;     // IPAddr of rlink used to forward packets
+   Agent*       pObj;      // NSObject for rtirouter
+   ns_addr_t    addr;      // ns address for rtirouter object
+   ipaddr_t     srcip;     // ALFRED add source ip/mask
+   ipaddr_t     smask;
+ } PTRoute_t;
+ 
+ // Define a structure for the nodelist cache.
+ typedef pair<ipaddr_t, ipportaddr_t> NCKey_t;  // Key for the nodecache
+ typedef pair<int,int>                NCVal_t;  // Value for the nodecache
+ typedef map<NCKey_t, NCVal_t>        NCMap_t;  // Map for nodecache
+ typedef NCMap_t::value_type          NCPair_t; // Value Pair
+ 
+ // Define structures for the routing entries
+ typedef struct ROUTE_ENTRY* RPtr;
+ typedef struct ROUTE_ENTRY {
+   ipaddr_t       ipaddr;  // Ultimate target ip address(s)
+   ipaddr_t       mask;    // Mask for route aggregations
+   NsObject*      pHead;   // ns object to forward packet to
+   // ALFRED add source-based routing support
+   ipaddr_t       srcip;
+   ipaddr_t       smask;
+ } RouteEntry;
+ 
+ class RTIRouter : public Agent {
+   public :
+     RTIRouter();
+     ~RTIRouter();
+     int command(int, const char*const*);
+     void recv(Packet* p, Handler*);  // Receive from local system
+     void rrecv(Packet* p, Handler*); // Receive from remote system
+     // Static methods for managing passthrough routes
+     static void       AddPTRoute(ipaddr_t targ, ipaddr_t mask, ipaddr_t via,
+                                  ipaddr_t srcip, ipaddr_t smask);
+     static PTRoute_t* GetPTRoute(ipaddr_t targ, ipaddr_t srcip);
+  private:
+     // Private members
+     NCMap_t    nodeCache;        // Cache of nodes
+     int        nodeshift_;       // Nodeshift value from Simulator
+     RPtr       rTable_;          // Routing table
+     int        rTableSize_;      // Size of Routing table
+     int        rTableLength_;    // Number used entries in table
+     NsObject*  pDefaultRemoteRoute; // Points to head of ns object list
+                                     // For off-system routing defaults
+  private:
+     // Private member functions
+     NCVal_t   FindCache( ipaddr_t, ipportaddr_t);
+     NCVal_t   AddCache(  ipaddr_t, ipportaddr_t, short, short);
+     NsObject* Lookup( ipaddr_t, ipaddr_t );
+     void      AddRoute( ipaddr_t, NsObject*, ipaddr_t, ipaddr_t, ipaddr_t );
+     void      SetDefaultRemoteRoute(NsObject*);
+ };
+ 
+ #endif
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rtisched.cc pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtisched.cc
*** new_p/ns-allinone-2.27/ns-2.27/rti/rtisched.cc	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtisched.cc	Sun Feb  1 15:21:45 2004
***************
*** 0 ****
--- 1,925 ----
+ /* RTI Scheduler */
+ /* George F. Riley.  Georgia Tech College of Computing */
+ 
+ /* Part of the ns modifications to allow distributed simulations */
+ /* RTI Scheduler is subclassed from list scheduler, but uses */
+ /* RTIKIT to synchronize the timestamps for messages and */
+ /* calls RTIKIT_Tick periodically to process incomming messages */
+ 
+ #include <stdlib.h>
+ #include <math.h>
+ // libSynk/libbrti includes
+ extern "C" {
+ #include "brti.h"
+ }
+ 
+ //#define USE_BACKPLANE
+ //#undef  USE_BACKPLANE
+ #ifdef  USE_BACKPLANE
+ // Backplane includes
+ #include "backplane/dsim.h"
+ #include "backplane/dsimip.h"
+ #include "backplane/dsimtcp.h"
+ #endif
+ 
+ #ifndef WIN32
+ #include <sys/time.h>
+ #endif
+ 
+ #include "tclcl.h"
+ #include "config.h"
+ #include "scheduler-map.h"
+ #include "packet.h"
+ #include "agent.h"
+ #include "rti/rtisched.h"
+ #include "rti/rtilink.h"
+ #include "rti/rtirouter.h"
+ 
+ #undef  HDCF_IF
+ #ifdef  HDCF_IF
+ #include "fluidqueue.h"
+ #endif
+ 
+ #ifdef USE_COMPRESSION
+ #include "rti/rticompress.h"
+ #endif
+ 
+ #include "rtioob.h"
+ 
+ // STL Includes
+ 
+ #include <map>
+ 
+ typedef map<ipaddr_t, NsObject*> IPMap_t;
+ typedef IPMap_t::iterator        IPMap_it;
+ typedef IPMap_t::value_type      IPPair_t;
+ 
+ // ALFRED - ecc/ia64 fix
+ #define strtoll strtol
+ 
+ // ALFRED - pkt stats
+ #include "common/pktcount.h"
+ unsigned long long rlinkPktC;
+ 
+ IPMap_t IPMap;  // Map of ipaddresses vs. ns Node Object pointer
+ 
+ // ALFRED ip->rtirouter table
+ typedef struct _route_map_t {
+   ipaddr_t ipaddr;
+   ipaddr_t mask;
+   Agent *pAgent;
+   ipaddr_t srcip;
+   ipaddr_t smask;
+ } route_map_t;
+ route_map_t *rmap_;
+ unsigned int rmap_size_;
+ unsigned int rmap_len_;
+ Agent *GetIPRoute(ipaddr_t ipaddr, ipaddr_t srcip);
+ 
+ void AddLocalIP(ipaddr_t ipaddr, NsObject* pObj)
+ {
+ IPPair_t* pp = new IPPair_t(ipaddr, pObj);
+ 
+   if(0)printf("AddLocalIP, addr %08x objname %s\n", ipaddr, pObj->name()); 
+   IPMap.insert(*pp);
+ }
+ 
+ NsObject* GetLocalIP(ipaddr_t ipaddr)
+ {
+ IPMap_it it;
+ 
+   if(0)printf("RTISched::GetLocalIp %08x, size of map %d\n", ipaddr, IPMap.size()); 
+   it = IPMap.find(ipaddr);
+   if (it == IPMap.end()) return(NULL);  // Not found
+   return it->second; // Found
+ }
+ 
+ const char* GetLocalIPName(ipaddr_t ipaddr)
+ {
+ IPMap_it it;
+ 
+   it = IPMap.find(ipaddr);
+   if (it == IPMap.end()) return(NULL);  // Not found
+   return it->second->name(); // Found
+ }
+ 
+ unsigned long long evcount = 0; /* Debug..count events */ /* ALFRED - ull */
+ extern ULONG FM_nodeid;
+ extern ULONG FM_numnodes;
+ static  double lookahead;
+ 
+ static  RTI_ObjClassDesignator    ObjClass;   
+ static  RTI_ObjInstanceDesignator ObjInstance; 
+ #define OOB_GROUP_NAME "RTIOOB"
+ 
+ RTIScheduler::FreeVec_t RTIScheduler::FreeVec;
+ 
+ char* RTIScheduler::WhereMessage (/* Advise where to store Rx message */
+     long         MsgSize,        /* Size of RX Message */
+     void*        pNotUsed,       /* Context info */
+     long         MsgType)        /* Type specified by sender */
+ {
+ char* r;
+  if (FreeVec.size())
+    { // entries exist in free vector
+      r = FreeVec.back();
+      FreeVec.pop_back(); // Remove it
+      return r;
+    }
+  r = (char*)malloc(MsgSize + 16);
+  return r;
+ }
+ 
+ void RTIScheduler::FreeMessage(
+     char*         pMsg)
+ {
+   FreeVec.push_back(pMsg);
+ }
+ 
+ // Create the group for exchanging out-of-band data
+ static void CreateOOBGroup()
+ {
+ 
+   RTI_CreateClass(OOB_GROUP_NAME);
+ }
+ 
+ static void PublishOOBGroup()
+ {
+   ObjClass = RTI_GetObjClassHandle(OOB_GROUP_NAME);
+   if (ObjClass == NULL)
+     {
+       printf("Can't get objclasshandle for %s\n", OOB_GROUP_NAME);
+       exit(0);
+     }
+   // Publish and register my interest in this class
+   RTI_PublishObjClass(ObjClass);
+   ObjInstance = RTI_RegisterObjInstance(ObjClass);
+ }
+ 
+ // Join the group for exchanging out-of-band data
+ static void JoinOOBGroup()
+ {
+   if (! RTI_IsClassSubscriptionInitialized (ObjClass))
+     { //  Set up a context
+       RTI_InitObjClassSubscription (ObjClass, RTIScheduler::WhereMessage, NULL);
+     }
+   RTI_SubscribeObjClassAttributes(ObjClass);
+ }
+ 
+ void SendOOB(int t, int da, int dp, int sa, int sp,
+              unsigned long ep1, unsigned long ep2,
+              unsigned long ep3, unsigned long ep4)
+ {
+ char      work[255];
+ struct MsgS* pMsg = (struct MsgS*)&work;
+ int*         pMsgType = (int*)&pMsg[1];
+ RTIMsg_t* pm = (RTIMsg_t*)&pMsgType[1];
+ 
+   pMsg->TimeStamp = Scheduler::instance().clock() + lookahead;
+   *pMsgType = 1; // Note OOB Data
+   pm->t = (RTIMsgEnum_t)t;
+   pm->da = da;
+   pm->dp = dp;
+   pm->sa = sa;
+   pm->sp = sp;
+   pm->ep1 = ep1;
+   pm->ep2 = ep2;
+   pm->ep3 = ep3;
+   pm->ep4 = ep4;
+   RTI_UpdateAttributeValues(ObjInstance, pMsg,
+                             MSGS_SIZE(sizeof(*pm) + sizeof(int)),
+                             0);
+ }
+ #ifdef HAVE_FILTER
+ void SendOOBFilter(int t)
+ {
+   char      work[255];
+   struct MsgS* pMsg = (struct MsgS*)&work;
+   int*         pMsgType = (int*)&pMsg[1];
+   RTIFilterEnum_t* msg= (RTIFilterEnum_t*)&pMsgType[1];
+   pMsg->TimeStamp = Scheduler::instance().clock() + lookahead;
+   *pMsgType = 601601; // Note OOB Data for Filter
+   *msg = (RTIFilterEnum_t)t;
+   RTI_UpdateAttributeValues(ObjInstance, pMsg,
+                             MSGS_SIZE(sizeof(*msg)+sizeof(int)),0);
+ }
+ 
+ #endif /*HAVE_FILTER*/
+ // Needed for BRTI, not used
+ extern "C" {
+   void RequestRetraction(CoreRetractionHandle)
+   {
+   }
+ }
+ 
+ RTIScheduler* RTIScheduler::rtiinstance_;
+ 
+ static class RTISchedulerClass : public TclClass {
+ public:
+ 	RTISchedulerClass() : TclClass("Scheduler/RTI") {}
+ 	TclObject* create(int /* argc */, const char*const* /* argv */) {
+ 		return (new RTIScheduler());
+ 	}
+ } class_RTI_sched;
+ 
+ RTIScheduler::RTIScheduler()
+ {
+   // ALFRED ip->rtirouter
+   rmap_len_ = 0;
+   rmap_size_ = 100;
+   if ((rmap_ = (route_map_t *)malloc(sizeof(route_map_t) * \
+           rmap_size_)) == NULL) {
+     printf("RTIScheduler constructor: malloc() failed!\n");
+     exit(1);
+   }
+ }
+ 
+ extern "C" {
+   int gethostname(const char*, int);
+ }
+ char         hn[255]; /* Hostname */
+ int RTIScheduler::init(int argc, const char*const* argv)
+ {
+ char* argv1[2] = {"pdns", NULL};
+ int   argc1 = 1;
+ 
+   gethostname(hn, sizeof(hn));
+   if(0) printf("Hello from RTISched::init name %s, argc %d\n", name(), argc);
+   if(0) for (int i = 0; i < argc; i++) printf("arg %d - %s\n", i, argv[i]);
+   fprintf(stderr, "RTISched before RTIKIT initializer %s\n", hn);fflush(stderr);
+   RTI_Init(argc1, argv1);
+   // ALFRED get env var for DEBUG purposes
+   char *pdebug = getenv("PDNS_DEBUG");
+   pd_ = pdebug ? atoi(pdebug) : 0;
+   RTIKIT_Barrier();  /* Wait for others */
+   // SF init hack
+   for(int slf=0;slf<10000;slf++)Core_tick();
+   printf("RTI_Init COMPLETE! Node %d\n", FM_nodeid);fflush(stdout);
+ #ifdef  USE_BACKPLANE
+   DSHandle_t dsh = InitializeDSim(FM_nodeid);
+   TcpRegister(dsh);
+   IpRegister(dsh);
+   RegistrationComplete ( FM_nodeid, FM_numnodes);
+ #endif
+ 	// ALFRED - init counters
+   rlinkPktC = 0;
+ 	pktC = 0;
+ 	dropPkts = 0;
+   return(0);
+ }
+ 
+ void RTIScheduler::setclock(double clock)
+ {
+  clock_ = clock;
+ }
+ 
+ /*void DBLBTSDump();*/
+ 
+ /* Callbacks from RTI.C */
+ static int          Granted; /* TRUE if time advance granted */
+ typedef unsigned long MY_Time;  /* Use 32 bit int's for time */
+ TM_Time GrantedTime;            /* Time granted to */
+ static unsigned long long TotalReflects; /* ALFRED converted to ull */
+ 
+ NsObject* GetLocalIP(ipaddr_t ipaddr); // in scheduler.cc
+ 
+ static void TryToFree(ipaddr_t ipaddr, ipportaddr_t port)
+ {
+ Tcl& tcl = Tcl::instance();
+ static int firstpass = 1;
+ static int exists = 0;
+ int        r;
+ 
+  if (firstpass) 
+    { // See if the unload-agent proc exists
+      tcl.evalf("lsearch -exact [info procs] unload-agent");
+      tcl.resultAs(&r);
+      if (r >= 0)
+        { // Ok found it
+          if(0)printf("unload-agent exists\n");
+          exists = 1;
+        }
+      else
+        { // No unload-agent, just ignore
+          if(0)printf("unload-agent NOT FOUND\n");
+        }
+      firstpass = 0;
+    }
+  if (exists)
+    {
+      NsObject* pObj = GetLocalIP(ipaddr);
+      if (pObj)
+        { // Object found
+          char work[255];
+          tcl.evalf("%s findport %d", pObj->name(), port);
+          strcpy(work, tcl.result());
+          if (work[0] != 0)
+            { // Found the agent
+              if(0)printf("Freeing agent %s\n");
+              tcl.evalf("unload-agent %s",work);
+            }
+          else
+            {
+              if(0)printf("Can't find port %d\n", port);
+            }
+        }
+      else
+        {
+          if(0)printf("Can't find ipaddr %08x\n", ipaddr);
+        }
+    }
+ }
+ 
+ static ipportaddr_t TryToCreate(ipaddr_t ipaddr, ipaddr_t daddr,
+                                 ipportaddr_t dport,
+                                 unsigned long ep1,
+                                 unsigned long ep2,
+                                 unsigned long ep3)
+ {
+ Tcl& tcl = Tcl::instance();
+ static int firstpass = 1;
+ static int exists = 0;
+ int r;
+ int port = 0;
+ 
+  if (firstpass) 
+    { // See if the create-and-bind proc exists
+      tcl.evalf("lsearch -exact [info procs] create-and-bind");
+      tcl.resultAs(&r);
+      if (r >= 0)
+        { // Ok found it
+          if(0)printf("create-and-bind exists\n");
+          exists = 1;
+        }
+      else
+        { // No create-and-bind, just ignore
+          if(0)printf("create-and-bind NOT FOUND\n");
+        }
+      firstpass = 0;
+    }
+  if (exists)
+    {
+      // Since oob's are broadcast, we see our own.  So we need
+      // to check if the ipaddr is local, and only call create-and-bind
+      // if so.
+      NsObject* p = GetLocalIP(ipaddr);
+      if (p)
+        {
+          tcl.evalf("create-and-bind 0x%08x 0x%08x %d %d %d %d",
+                    ipaddr, daddr, dport, ep1, ep2, ep3);
+          tcl.resultAs(&port);
+          if(0)printf("The bound port is %d\n", port);
+        }
+    }
+  return port;
+ }
+ 
+ void ReflectAttributeValues (TM_Time T, struct MsgS* pMsg, long MsgSize, long MsgType)
+ {
+ RTIRouter*   pRouter;
+ RTIRouter**  ppRouter;
+ char*        pbuf;
+ RTIMsg_t*    pOOB;
+ int*         pMsgType;
+ char*        pMyData;
+ char         work[512];
+ 
+  pMsgType = (int*)&pMsg[1];
+ 
+ #ifdef HAVE_FILTER
+ if(*pMsgType == 601601)  
+    { // Got oob data for Filter
+      RTIFilterEnum_t* pm;
+      pm = (RTIFilterEnum_t*)&pMsgType[1];
+ 
+      Tcl& tcl = Tcl::instance();
+      
+      tcl.evalf("info exists filters");
+      int proceed = atoi(tcl.result());
+      if (proceed) {
+        tcl.evalf("llength $filters");
+        
+        int filters_length  = atoi((char*)tcl.result());
+        printf("%d filters in system\n",filters_length);fflush(stdout);
+        char filter[10];
+ 
+        if(*pm == RTIFilterStart) {
+ 	 printf("Turning filtering ON\n");fflush(stdout);
+ 	 for (int i = 0; i < filters_length ;i++) {
+ 	   tcl.evalf("lindex  $filters  %d",i);	
+ 	   strcpy(filter,tcl.result());
+ 	   if(1)printf("Filter is %s",filter);
+ 	   tcl.evalf("%s on",filter);
+ 	 }
+        }
+        if (*pm == RTIFilterStop) {
+ 	 printf("Turning filtering OFF\n");fflush(stdout);
+ 	 for (int i = 0; i < filters_length ;i++) {
+ 	   tcl.evalf("lindex  $filters  %d",i);	
+ 	   strcpy(filter,tcl.result());
+ 	   if(0)printf("Filter is %s",filter);
+ 	   tcl.evalf("%s off",filter);
+ 	 }
+        }
+      } else { 
+        printf("No global variable \"filters\" exist in this system\n");
+        fflush(stdout);
+      }
+      return;
+    }
+ #endif /* HAVE_FILTER*/
+ 
+ #ifdef  HDCF_IF
+  typedef struct {
+    size_t WhichQ;
+    Size_t Size;
+    Rate_t ChangeRate;
+    Rate_t  InputFlowRate;
+    Rate_t  OutputFlowRate;
+  } HDCF_t;
+  if(*pMsgType == 4321)
+  {
+      HDCF_t* pHDCF = (HDCF_t*)&pMsgType[1];
+      int s = MsgSize - sizeof(struct MsgS) - sizeof(int);
+      printf("Got HDCF_IF msg, total size %d residual size %d\n",
+             MsgSize, s);
+      int c = s / sizeof(HDCF_t); // Number of update entries
+      for (int i = 0; i < c; i++, pHDCF++)
+        {
+          FluidQueue* fq = FluidQueue::GetFQ(pHDCF->WhichQ);
+          if (fq)
+            {
+              fq->Update(T, pHDCF->Size, pHDCF->ChangeRate,
+                         pHDCF->InputFlowRate, pHDCF->OutputFlowRate);
+            }
+          else
+            {
+              printf("RTISched::Reflect, ignoring fq update for %d\n",
+                     pHDCF->WhichQ);
+            }
+        }
+      MB_FreeBuffer(RTIFreePool, pMsg);
+      return;
+  }
+ #endif
+ 
+ #ifdef VEIL_IF
+  if(*pMsgType == 4321)
+  {
+      char *pvmsg = (char *)pMsg;
+      RTIScheduler& s = RTIScheduler::rtiinstance();
+      s.setclock(T);
+      void veil_recv( char * );
+      veil_recv( pvmsg );
+      MB_FreeBuffer(RTIFreePool, pMsg);
+      return;
+  }
+ #endif
+ 
+ #ifdef USE_OOB
+  if (0)//KALYAN:(*pMsgType)
+    { // Got oob data
+      pOOB = (RTIMsg_t*)&pMsgType[1];
+      if(0)printf("Got oob t %d da %08x dp %d sa %08x sp %d\n",
+             pOOB->t, pOOB->da, pOOB->dp, pOOB->sa, pOOB->sp);
+      switch(pOOB->t) {
+        case  RTIM_LoadNewAgent:  // Request a new agent be loaded
+          if(0)printf("TTC, ep1 %d ep2 %d ep3 %d\n", 
+                      pOOB->ep1, // Instance id
+                      pOOB->ep2, // req size
+                      pOOB->ep3);// Reply size
+          TryToCreate(pOOB->da, pOOB->sa, pOOB->sp,
+                      pOOB->ep1, // Instance id
+                      pOOB->ep2, // req size
+                      pOOB->ep3);// Reply size
+          break;
+        case  RTIM_UnloadAgent :  // Unload an existing agent
+          TryToFree( pOOB->da, pOOB->dp);
+          break;
+        case  RTIM_SetDestPort :  // Set destination port for an agent
+          NsObject* pObj = GetLocalIP(pOOB->sa);
+          Tcl&      tcl  = Tcl::instance();
+          if (pObj)
+            { 
+              if(0)printf("Found local ip %08x node %s\n",
+                          pOOB->sa, pObj->name());
+              tcl.evalf("%s findport %d", pObj->name(), pOOB->sp);
+              strcpy(work, tcl.result());
+              if (work[0] != 0)
+                { // Found the agent
+                  tcl.evalf("[Simulator instance] rconnect %s 0x%08x %d",
+                            work, pOOB->da, pOOB->dp); // do the remote connect
+                  if(0)printf("SDP, rconnect %s 0x%08x %d\n", work, 
+                         pOOB->da, pOOB->dp);
+                }
+              else
+                {
+                  printf("Can't find agent on port %d, node %s\n",
+                         pOOB->sp, pObj->name());
+                }
+            }
+          else
+            { 
+              if(0)printf("Can't find node for localip %08x\n", pOOB->sa);
+            }
+          break;
+      } 
+      MB_FreeBuffer (RTIFreePool, pMsg); /* Return buffer to available pool */
+      return;
+    }
+ #endif
+ 
+  GrantedTime = T;
+ if(0)printf("Host %s ReflectTime %f MSize %ld MTime %f\n",
+         hn, T, MsgSize, pMsg->TimeStamp);
+ 
+   if(*pMsgType==RTIKIT_nodeid)
+     {/*Ignore self msg*/
+       RTILink::FreeMessage((char*)pMsg);
+       return;
+     }
+ 	
+  TotalReflects++; /* ALFRED - moved after self reflect drop */
+ 
+  /* Get a packet from available pool and load up the bits */
+  Packet* p = Packet::alloc();
+  p->time_ = T; // Set event time
+  pMyData = (char*)&pMsgType[1];
+ #ifdef USE_BACKPLANE
+  char baggage[2000]; // Fix this..need malloc and getmessagesize()
+  int outlth = sizeof(baggage);
+  ImportMessage((char*)(pMyData), MsgSize - sizeof(struct MsgS) - sizeof(int),
+               (char*)p, baggage, &outlth);
+ #else
+ 
+ #ifdef USE_COMPRESSION
+  Uncompress((unsigned long*)p->bits(),
+             (unsigned long*)(pMyData),
+             (MsgSize - sizeof(struct MsgS) - sizeof(long)) / 4);
+ #else
+  memcpy(p->bits(), (char*)(pMyData), MsgSize - sizeof(struct MsgS) - sizeof(int));
+ #endif
+ 
+ #endif
+  RTIScheduler& s = RTIScheduler::rtiinstance();
+  assert(T >= clock_); // ALFRED check forward progress
+  s.setclock(T); // Set new clock time
+  pbuf = (char*)pMsg;
+  ppRouter = (RTIRouter**)&pbuf[MsgSize];
+  pRouter = *ppRouter;
+  pRouter->rrecv(p, NULL);
+  RTILink::FreeMessage((char*)pMsg); /* Return buffer to available pool */
+ }
+ 
+ extern "C" {
+ int TM_PrintHisto(void);
+ void MyHereProc (long MsgSize, struct MsgS *Msg) {}
+ }
+ 
+ double getime; // Global event time for debugging
+ int    ghalted;// Global halted for debugging
+ 
+ void TimeAdvanceGrant (TM_Time T)
+ {
+  GrantedTime = T;
+  if(ghalted && 0)printf("Host %s GrantTime %f\n", hn, T);
+  Granted = 1;
+ }
+ 
+ void RTIScheduler::run()
+ { 
+ #define LARGE_TIME 1000000.0
+   int   i;
+   char* argv[2] = {"nsdt", NULL};
+   int   argc = 1;
+   unsigned long long RequestCount = 0; // ALFRED converted to ull
+   Event* e;
+   double etime;
+   TIMER_TYPE t1, t2; //KALYAN
+ 
+   // ALFRED cleaned up code
+   printf("Entering RTI Scheduler, host %s\n", hn);
+   Tcl::instance().evalc("[Simulator instance] forced-lookahead");
+   Tcl::instance().resultAs(&i);
+   if (i) {
+     /* Forced value specified (for debugging only) */
+     Tcl::instance().evalc("[Simulator instance] set forced-lookahead-value");
+     Tcl::instance().resultAs(&lookahead);
+     printf("Forced LA is %f\n", lookahead);
+   } else {
+     Tcl::instance().evalc("[Simulator instance] get-lookahead");
+     Tcl::instance().resultAs(&lookahead);
+     printf("Calculated LA is %f\n", lookahead);
+   }
+   RTI_SetLookAhead(lookahead); /* Set the lookahead value */
+   printf("%s using lookahead value of %f\n", hn, lookahead);
+   printf("RTISched after RTIKIT initializer %s\n", hn);fflush(stdout);
+   fprintf(stderr, "RTISched after RTIKIT initializer %s\n", hn);fflush(stderr);
+   /* Create and join groups for all output links */
+   Tcl::instance().evalc("foreach i [Node info instances] {\n"
+                         "$i create-groups\n}");
+   CreateOOBGroup();  /* Create the group for OOB Data */
+   RTIKIT_Barrier();  /* Wait for others */
+   printf("After create group barrier %s\n", hn);fflush(stdout);
+ 
+   Tcl::instance().evalc("foreach i [Node info instances] {\n"
+                         "$i publish-groups\n}");
+   PublishOOBGroup(); /* Join the group for OOB Data */
+   RTIKIT_Barrier();  /* Wait for others */
+   printf("After publish group barrier %s\n", hn);fflush(stdout);
+ 
+   Tcl::instance().evalc("foreach i [Node info instances] {\n"
+                         "$i join-groups\n}");
+   JoinOOBGroup();    /* Join the group for OOB Data */
+   RTIKIT_Barrier();  /* Wait for others */
+   printf("After join group barrier %s\n", hn);fflush(stdout);
+ 
+   /* Log the start time of the actual simulation */
+   Tcl::instance().evalc( "[Simulator instance] sim-start");
+ 
+   /* Allocate a few packets before entering loop so we have some on free list */
+   for (int i1 = 0; i1 < 20; i1++) {
+     Packet* p = Packet::alloc();
+     Packet::free(p);
+   } 
+   instance_ = this;
+   rtiinstance_ = this;
+   
+ #if 1 //Set this to 0 if using libSynk versions prior to 29Dec03
+   RTIKIT_FinalizeTopology();
+ #endif
+ 
+   printf("Entering sched main loop, host %s\n", hn);fflush(stdout);
+   Tcl::instance().evalc("[Simulator instance] log-simstart");
+   TIMER_NOW(t1);
+   // Main simulation loop
+ 	while (!halted_) {
+     e = earliest();
+     if (e) {
+       etime = e->time_;
+     } else {
+       etime = LARGE_TIME;
+     }
+     getime = etime;
+     if (etime > GrantedTime) { // Need to see if ok
+       if(0)printf("Trying to adv to %f\n", etime);
+       Granted = 0;
+       RTI_NextEventRequest(etime);
+       RequestCount++;
+ 			while(!Granted) Core_tick();
+     }
+     e = (Event*)earliest(); // In case a new one came in
+     if (e) {
+       etime = e->time_;
+     } else {
+       etime = LARGE_TIME;
+     }
+     if (GrantedTime >= LARGE_TIME) break; // Done
+     if (GrantedTime >= etime && e != NULL) { // Time to process this event
+       e = deque(); // remove this one
+       assert(e->time_ >= clock_); // ALFRED check forward progress
+       clock_ = e->time_;
+       e->uid_ = - e->uid_;
+       e->handler_->handle(e);
+       evcount++;
+     }
+     if(pd_){static double nxtp=0;if(clock_>=nxtp){double dt;TIMER_NOW(t2);dt=TIMER_DIFF(t2,t1);nxtp+=1.0;printf("Simnum= %d Now= %lf elapsedsecs= %lf dlink= %llu rlink=%llu totpktH= %llu dropped=%llu RqC= %llu EvC= %llu MPTS= %lf MEVS= %lf\n",FM_nodeid,clock_,dt,pktC,rlinkPktC,(pktC+rlinkPktC),dropPkts,RequestCount,evcount,(pktC+rlinkPktC)/dt/1000000.0,evcount/dt/1000000.0);fflush(stdout);}}//KALYAN
+   }
+   ghalted = 1;
+   printf("%s exited event main loop RqC %llu EvC %llu\n", 
+       hn, RequestCount, evcount);
+   printf("-----------\n");
+   printf("Packet stats:\n");
+   printf("  dlink packet hops: %llu\n", pktC);
+   printf("  rlink packet hops: %llu\n", rlinkPktC);
+   printf("  total packet hops: %llu\n", pktC+rlinkPktC);
+   printf("  drop-tail packets dropped: %llu\n", dropPkts);
+   printf("-----------\n");
+   /*if(0)DBLBTSDump();*/
+   fflush(stdout);
+   // Let's all agree we are all done
+   while (1) {
+     etime = LARGE_TIME + 10;
+     Granted = 0;
+     RTI_NextEventRequest(etime);
+     while(!Granted) Core_tick();
+     if (GrantedTime >= etime) break; /* All agree */
+   }
+ 
+   if(0)printf("Before exit barrier\n");
+   RTIKIT_Barrier();  /* Wait for others */
+   // KALYAN termination hack
+   {TIMER_TYPE t1,t2; double dt; TIMER_NOW(t1);do{FM_extract(~0);
+    TIMER_NOW(t2);dt=TIMER_DIFF(t2,t1);}while(dt<2/*secs*/);}
+   if(0)printf("After exit barrier\n");
+   printf("Total Reflect Msgs received %llu\n", TotalReflects);fflush(stdout);
+   TM_PrintStats();
+   printf("Host %s exiting run\n", hn);fflush(stdout);
+ }
+ 
+ 
+ char scrbuf[100]; // tclresults for getlocalipname .. gfr
+ int RTIScheduler::command(int argc, const char*const* argv)
+ {
+ Tcl& tcl = Tcl::instance();
+  
+   if (argc == 3)
+     {
+       if (strcmp(argv[1], "get-local-ip") == 0)
+         { // Get the name of tcl object representing the specified ip addr
+           // ALFRED fix this to support dotted-quad
+           struct in_addr addr;
+           ipaddr_t ipaddr;
+           if (strchr(argv[2], '.') != NULL) {
+             inet_aton(argv[2], &addr);
+             ipaddr = ntohl(addr.s_addr);
+           } else {
+             ipaddr = strtol(argv[2], NULL, 0);
+           }
+           if(0)printf("getting local ip %s\n", argv[2]);
+           const char* r = GetLocalIPName(ipaddr);
+           *scrbuf = 0;
+           if (r) {
+             strcpy(scrbuf, r);
+           } else {
+             strcpy(scrbuf, "0");
+           }
+           tcl.result(scrbuf);
+           return (TCL_OK);
+         }
+ #ifdef HAVE_FILTER
+       if (strcmp(argv[1], "send-oob-filter") == 0)
+ 	{ // Get the name of tcl object representing the specified ip addr
+ 	  if(1)printf("sending start filtering OOB msg");
+ 
+ 	  if (strcmp(argv[2], "on") == 0){
+ 	    SendOOBFilter(RTIFilterStart);
+ 	    return (TCL_OK);
+ 	  }
+ 	  if (strcmp(argv[2], "off") == 0){
+ 	    SendOOBFilter(RTIFilterStop);
+ 	    return (TCL_OK);
+ 	  }
+ 	  return (TCL_ERROR);
+ 	}
+ #endif /*HAVE_FILTER*/
+     }
+   
+   if (argc == 4)
+     {
+       if (strcmp(argv[1], "add-local-ip") == 0)
+         {
+           AddLocalIP(strtoll(argv[2], NULL, 0),
+                      (NsObject*)TclObject::lookup(argv[3]));
+           return (TCL_OK);
+         }
+       if (strcmp(argv[1], "get-iproute") == 0) {
+         struct in_addr addr;
+         ipaddr_t ipaddr;
+         *scrbuf = 0;
+         Agent *pAgent = (Agent *)TclObject::lookup(argv[2]);
+         if (strchr(argv[3], '.') != NULL) {
+           inet_aton(argv[3], &addr);
+           ipaddr = ntohl(addr.s_addr);
+         } else {
+           ipaddr = strtol(argv[3], NULL, 0);
+         }
+         Agent *pRoute = GetIPRoute(ipaddr, pAgent->get_ipaddr());
+         if (pRoute == NULL) {
+           strcpy(scrbuf, "0");
+         } else {
+           strcpy(scrbuf, pRoute->name());
+         }
+         tcl.result(scrbuf);
+         return TCL_OK;
+       }
+     }
+   if (argc == 5) {
+       if (strcmp(argv[1], "iproute-connect") == 0) {
+         struct in_addr addr;
+         ipaddr_t ipaddr;
+         ipportaddr_t dport = strtol(argv[4], NULL, 0);
+         Agent *pAgent = (Agent *)TclObject::lookup(argv[2]);
+         if (strchr(argv[3], '.') != NULL) {
+           inet_aton(argv[3], &addr);
+           ipaddr = ntohl(addr.s_addr);
+         } else {
+           ipaddr = strtol(argv[3], NULL, 0);
+         }
+         Agent *pRoute = GetIPRoute(ipaddr, pAgent->get_ipaddr());
+         if (pRoute == NULL) {
+           printf("Sim::rtischeduler: No IPRoute for %08x:%d! ", ipaddr, dport);
+           printf("Are you sure target is remote?\n");
+           exit(1);
+         }
+         Tcl &tcl = Tcl::instance();
+         tcl.evalf("[Simulator instance] connect %s %s", pAgent->name(), \
+             pRoute->name());
+         if(0)printf("Sim::rtischeduler: rconnected %s %s\n", pAgent->name(),pRoute->name());
+         return (TCL_OK);
+       }
+   }
+   if (argc >= 7) 
+     {
+       // ALFRED ip->rtirouter
+       if (strcmp(argv[1], "add-iproute") == 0) {
+         struct in_addr addr;
+         ipaddr_t ipaddr, mask, srcip, smask;
+         Agent *pAgent = (Agent *)TclObject::lookup(argv[6]);
+         if (strchr(argv[2], '.') != NULL) {
+           inet_aton(argv[2], &addr);
+           ipaddr = ntohl(addr.s_addr);
+         } else {
+           ipaddr = strtol(argv[2], NULL, 0);
+         }
+         if (strchr(argv[3], '.') != NULL) {
+           inet_aton(argv[3], &addr);
+           mask = ntohl(addr.s_addr);
+         } else {
+           mask = strtol(argv[3], NULL, 0);
+         }
+         if (strchr(argv[4], '.') != NULL) {
+           inet_aton(argv[4], &addr);
+           srcip = ntohl(addr.s_addr);
+         } else {
+           srcip = strtol(argv[4], NULL, 0);
+         }
+         if (strchr(argv[5], '.') != NULL) {
+           inet_aton(argv[5], &addr);
+           smask = ntohl(addr.s_addr);
+         } else {
+           smask = strtol(argv[5], NULL, 0);
+         }
+         AddIPRoute(ipaddr, mask, pAgent, srcip, smask);
+         return (TCL_OK);
+       }
+       if (strcmp(argv[1], "rti-oob") == 0)
+         {
+           unsigned long ep1 = 0; // The "extra" parameters
+           unsigned long ep2 = 0;
+           unsigned long ep3 = 0;
+           unsigned long ep4 = 0;
+           if(0)printf("Sendoob, %s %s %s %s %s\n", 
+                  argv[2], argv[3], argv[4], argv[5], argv[6]);
+           if (argc > 7)  ep1 = strtoll(argv[7], NULL, 0);
+           if (argc > 8)  ep2 = strtoll(argv[8], NULL, 0);
+           if (argc > 9)  ep3 = strtoll(argv[9], NULL, 0);
+           if (argc > 10) ep4 = strtoll(argv[10], NULL, 0);
+           SendOOB(atoi(argv[2]), // Msg Type
+                   strtoll(argv[3], NULL, 0), // Dest Addr
+                   strtoll(argv[4], NULL, 0), // Dest port 
+                   strtoll(argv[5], NULL, 0), // Src Addr
+                   strtoll(argv[6], NULL, 0), // Src port
+                   ep1, ep2, ep3, ep4);
+           return (TCL_OK);
+         }
+     }
+   return MapScheduler::command(argc, argv);
+ }
+ 
+ // ALFRED ip->rtirouter methods
+ void RTIScheduler::AddIPRoute(ipaddr_t ipaddr, ipaddr_t mask, Agent *pAgent,
+     ipaddr_t srcip, ipaddr_t smask) {
+ 
+   if (rmap_len_ >= rmap_size_) {
+     route_map_t *tmp;
+     if ((tmp = (route_map_t *)realloc(rmap_, sizeof(route_map_t) * \
+             (rmap_size_ + 100))) == NULL) {
+       printf("RTIScheduler::AddIPRoute, realloc() failed!\n");
+       exit(1);
+     }
+     rmap_ = tmp;
+     rmap_size_ += 100;
+   }
+   rmap_[rmap_len_].ipaddr = ipaddr;
+   rmap_[rmap_len_].mask = mask;
+   rmap_[rmap_len_].pAgent = pAgent;
+   rmap_[rmap_len_].srcip = srcip;
+   rmap_[rmap_len_].smask = smask;
+   rmap_len_++;
+ }
+ 
+ Agent *GetIPRoute(ipaddr_t ipaddr, ipaddr_t srcip) {
+ 
+   if(0)printf("GetIPRoute called, d %08x s %08x\n", ipaddr,srcip);
+ 
+   for (int i = 0; i < rmap_len_; i++) {
+     if (rmap_[i].srcip != 0 && rmap_[i].smask != 0) {
+       if(0)printf(" -->non-zero: %08x %08x %08x %08x\n", rmap_[i].ipaddr,rmap_[i].mask,rmap_[i].srcip,rmap_[i].smask);
+       if(0)printf("   masked: %08x %08x %08x %08x\n", rmap_[i].ipaddr & rmap_[i].mask, ipaddr & rmap_[i].mask, rmap_[i].srcip & rmap_[i].smask, srcip & rmap_[i].smask);
+       if ((rmap_[i].srcip & rmap_[i].smask) == (srcip & rmap_[i].smask) &&
+         (rmap_[i].ipaddr & rmap_[i].mask) == (ipaddr & rmap_[i].mask)) {
+         if(0)printf("  SRC returning pAgent: %s\n", rmap_[i].pAgent->name());
+         return rmap_[i].pAgent;
+       }
+     }
+   }
+   for (int i = 0; i < rmap_len_; i++) {
+     if ((rmap_[i].ipaddr & rmap_[i].mask) == (ipaddr & rmap_[i].mask)) {
+       if(0)printf("  REG returning pAgent: %s\n", rmap_[i].pAgent->name());
+       return rmap_[i].pAgent;
+     }
+   }
+   return NULL;
+ }
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/rtisched.h pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtisched.h
*** new_p/ns-allinone-2.27/ns-2.27/rti/rtisched.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/rtisched.h	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,37 ----
+ /* RTI Scheduler */
+ /* George F. Riley.  Georgia Tech College of Computing */
+ 
+ /* Part of the ns modifications to allow distributed simulations */
+ /* RTI Scheduler is subclassed from map scheduler, but uses */
+ /* RTIKIT to synchronize the timestamps for messages and */
+ /* calls RTIKIT_Tick periodically to process incomming messages */
+ 
+ #ifndef __RTISCHED_H__
+ #define __RTISCHED_H__
+ 
+ #include "scheduler-map.h"
+ 
+ #include <vector>
+ 
+ class RTIScheduler : public MapScheduler {
+ public:
+ 	RTIScheduler();
+ 	virtual int init(int, const char*const*);
+ 	static RTIScheduler& rtiinstance() { return (*rtiinstance_); }
+ 	virtual void run();
+   void setclock( double ); // Set new clock value
+ 	int command(int argc, const char*const* argv);
+   static char* WhereMessage (long, void*, long); // Used for oob messags
+   static void  FreeMessage(char*);
+   typedef vector<char*> FreeVec_t;
+   static  FreeVec_t FreeVec;
+ 
+ protected:
+ 	static RTIScheduler* rtiinstance_;
+   int pd_; // ALFRED pdns debug env var
+   void AddIPRoute(ipaddr_t ipaddr, ipaddr_t mask, Agent *pAgent, 
+       ipaddr_t srcip, ipaddr_t smask);
+   //Agent *GetIPRoute(ipaddr_t ipaddr, ipaddr_t srcip);
+ };
+ 
+ #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/rti/veilmsg.h pdns-ia64/ns-allinone-2.27/ns-2.27/rti/veilmsg.h
*** new_p/ns-allinone-2.27/ns-2.27/rti/veilmsg.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/rti/veilmsg.h	Sat Jan 31 14:52:50 2004
***************
*** 0 ****
--- 1,136 ----
+ /*---------------------------------------------------------------------------*/
+ /*---------------------------------------------------------------------------*/
+ #ifndef __VEILMSG_H
+ #define __VEILMSG_H
+ 
+ /*---------------------------------------------------------------------------*/
+ #include <stdio.h>
+ #include <brti.h>
+ 
+ /*---------------------------------------------------------------------------*/
+ #define SIN_FAMILY(/*struct sockaddr_in **/_sin) (!(_sin)?0:(_sin)->sin_family)
+ #define SIN_IP(/*struct sockaddr_in **/_sin) (!(_sin)?0:(_sin)->sin_addr.s_addr)
+ #define SIN_PORT(/*struct sockaddr_in **/_sin) (!(_sin)?0:(_sin)->sin_port)
+ 
+ /*---------------------------------------------------------------------------*/
+ typedef unsigned long SockPort;
+ typedef unsigned long SockAddr;
+ 
+ /*---------------------------------------------------------------------------*/
+ #define MICROSEC 1e-6
+ #define MILLISEC 1e-3
+ #define SEC 1.0
+ 
+ /*---------------------------------------------------------------------------*/
+ typedef enum
+ {
+     VEIL_MSG_CONNECT_REQ,
+     VEIL_MSG_CONNECT_RESP,
+     VEIL_MSG_DATA_NOTIFY,
+     VEIL_MSG_SOCKET_DATA,
+     VEIL_MSG_DISCONNECT
+ } VeilMsgType;
+ 
+ /*---------------------------------------------------------------------------*/
+ #define VEIL_MSG_TAG 0
+ 
+ /*---------------------------------------------------------------------------*/
+ /*                                                                           */
+ /*---------------------------------------------------------------------------*/
+ typedef struct
+ {
+ } VeilMsgConnectReq;
+ 
+ /*---------------------------------------------------------------------------*/
+ /*                                                                           */
+ /*---------------------------------------------------------------------------*/
+ typedef struct
+ {
+     int success_code;
+ } VeilMsgConnectResp;
+ 
+ /*---------------------------------------------------------------------------*/
+ /*                                                                           */
+ /*---------------------------------------------------------------------------*/
+ typedef struct
+ {
+     long tot_bytes; /*Total #bytes sent by sender between connect & disconnect;
+                      -1 if unknown*/
+ } VeilMsgDisconnect;
+ #define set_veil_msg_disconnect( m, tb ) do{                                 \
+     (m)->tot_bytes = tb;                                                     \
+     }while(0)
+ 
+ /*---------------------------------------------------------------------------*/
+ /*                                                                           */
+ /*---------------------------------------------------------------------------*/
+ typedef struct
+ {
+     int nbytes;
+ } VeilMsgDataNotify;
+ #define set_veil_msg_data_notify( m, nb ) do{                                 \
+     (m)->nbytes = nb;                                                         \
+     }while(0)
+ 
+ /*---------------------------------------------------------------------------*/
+ /*                                                                           */
+ /*---------------------------------------------------------------------------*/
+ typedef struct
+ {
+     #define VEILDATACHUNKSIZE 1024
+     char data[VEILDATACHUNKSIZE];
+     int datalen; /*0<datalen<=VEILDATACHUNKSIZE*/
+ } VeilMsgSocketData;
+ #define set_veil_msg_socket_data( m, buf, dlen ) do{                          \
+     ASSERT( 0 < (dlen) && (dlen) <= VEILDATACHUNKSIZE, ("") );                \
+     memcpy( (m)->data, buf, dlen );                                           \
+     (m)->datalen = dlen;                                                      \
+     }while(0)
+ 
+ /*---------------------------------------------------------------------------*/
+ /*                                                                           */
+ /*---------------------------------------------------------------------------*/
+ typedef struct veil_msg_struct
+ {
+     struct MsgS rti_data;
+     int dummy; /*For pdns compatibility*/
+     SockAddr src_ip, dest_ip;
+     SockPort src_port, dest_port;
+     VeilMsgType type;
+     union
+     {
+         VeilMsgConnectReq creq;
+ 	VeilMsgConnectResp cresp;
+ 	VeilMsgDisconnect dcon;
+ 	VeilMsgDataNotify dntfy;
+ 	VeilMsgSocketData sdata;
+     } msg;
+     struct veil_msg_struct *next; /*To link msgs in a list*/
+ } VeilMsg;
+ #define set_veil_msg( m, ty, sip, spt, dip, dpt ) do{                         \
+     (m)->dummy = 4321;                                                        \
+     (m)->type = ty;                                                           \
+     (m)->src_ip = sip; (m)->dest_ip = dip;                                    \
+     (m)->src_port = spt; (m)->dest_port = dpt;                                \
+     }while(0)
+ 
+ /*---------------------------------------------------------------------------*/
+ void print_veilmsg_hdr( FILE *out, VeilMsg *vmsg );
+ 
+ /*---------------------------------------------------------------------------*/
+ ulong dot_to_ulong( const char *s );
+ const char *ulong_to_dot( ulong n );
+ 
+ /*---------------------------------------------------------------------------*/
+ /* SockAddr --> [0..max_addr-1] hashing service.                             */
+ /*                                                                           */
+ /*---------------------------------------------------------------------------*/
+ struct HashIPAddrStruct;
+ typedef struct HashIPAddrStruct *HashIPAddr;
+ HashIPAddr hash_ipaddr_init( int max_addr );
+ int hash_ipaddr_find_index( HashIPAddr h, SockAddr addr );
+ void hash_ipaddr_printstats( HashIPAddr h, FILE *out );
+ void hash_ipaddr_wrapup( HashIPAddr h );
+ 
+ /*---------------------------------------------------------------------------*/
+ #endif /*__VEILMSG_H*/
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcl/lib/gt-rtilib.tcl pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/lib/gt-rtilib.tcl
*** new_p/ns-allinone-2.27/ns-2.27/tcl/lib/gt-rtilib.tcl	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/lib/gt-rtilib.tcl	Sat Jan 31 14:51:27 2004
***************
*** 0 ****
--- 1,12 ----
+ # Additions to ns-lib.tcl for the RTIKIT version of ns
+ # George F. Riley, Georgia Tech, Winter 1999
+ 
+ # First get some individual class additions
+ source ../rti/ns-rtinode.tcl
+ source ../rti/ns-rtilink.tcl
+ source ../rti/ns-rtiagent.tcl
+ source ../rti/ns-rtisim.tcl
+ 
+ # And the default settings
+ source ../rti/ns-rti-default.tcl
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcl/lib/ns-lib.tcl pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/lib/ns-lib.tcl
*** new_p/ns-allinone-2.27/ns-2.27/tcl/lib/ns-lib.tcl	Wed Jan 28 20:49:43 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/lib/ns-lib.tcl	Sat Jan 31 14:51:27 2004
***************
*** 213,218 ****
--- 213,222 ----
  # PGM
  #source ../pgm/ns-pgm.tcl
  
+ # GFR Additions for pdns
+ source gt-rtilib.tcl
+ # End GFR Additions
+ 
  #LMS
  source ../mcast/ns-lms.tcl
  
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcl/lib/ns-packet.tcl pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/lib/ns-packet.tcl
*** new_p/ns-allinone-2.27/ns-2.27/tcl/lib/ns-packet.tcl	Wed Jan 28 20:49:43 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/lib/ns-packet.tcl	Sat Jan 31 14:51:27 2004
***************
*** 157,162 ****
--- 157,163 ----
  	SCTP
  	Smac
  	NV
+   RTI
  } {
  	add-packet-header $prot
  }
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rti-default.tcl pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rti-default.tcl
*** new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rti-default.tcl	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rti-default.tcl	Sat Jan 31 14:52:18 2004
***************
*** 0 ****
--- 1,51 ----
+ Agent set dst_ipaddr_ 0
+ Agent set dst_ipport_ -1
+ Agent set my_ipaddr_ 0
+ Agent set my_port_ -1
+ 
+ RTILink set delay_ 100ms
+ RTILink set bandwidth_ 1.5Mb
+ RTILink set ipaddr_ 0
+ RTILink set netmask_ 0
+ RTILink set debug_ 0
+ RTILink set off_ip_ 0
+ RTILink set avoidReordering_ false; # ALFRED for ns-2.27, not used
+ 
+ DropTargetAgent set debug_ 0
+ 
+ if [TclObject is-class Agent/TCP/Listener] {
+   Agent/TCP/Listener instproc done_data {} { }
+   Agent/TCP/Listener set debug_ 1; # Default debug level, 0 = off, 3 = max
+   Agent/TCP/Listener set trace_enable_ 0; # Trace level for Net Anim, 0 = off,
+                                           # 1 = syn/table, 2 = synack, 3 = max
+   Agent/TCP/Listener set trace_interval_ 10; # Trace every nth packet
+   Agent/TCP/Listener set max_synack_retries_ 0; # Number of SYN+ACK 
+                                                 # retries, [0:disable]
+   Agent/TCP/Listener set table_size_ 256; # TCP connection table size
+   Agent/TCP/Listener set entry_expire_ 6.0; # TCP connection table entry
+                            # expiration time after intial SYN, enabled only 
+                            # when max_synack_retries_ == 0 (disabled)
+   Agent/TCP/Listener set filter_enable_ 0; # Egress filtering [0:disable]
+   Agent/TCP/Listener set filter_trigger_ 0.75; # filter trigger threshold 
+   Agent/TCP/Listener set filter_release_ 0.50; # filter release threshold 
+   Agent/TCP/Listener set prebinding_ 0; # FullTcpAgent prebinding support
+ 	Agent/TCP/Listener set segsperack_ 1; # ACK frequency
+ 	Agent/TCP/Listener set spa_thresh_ 0; # below do 1 seg per ack [0:disable]
+ 	Agent/TCP/Listener set segsize_ 536; # segment size
+ 	Agent/TCP/Listener set tcprexmtthresh_ 3; # num dupacks to enter recov
+ 	Agent/TCP/Listener set iss_ 0; # Initial send seq#
+ 	Agent/TCP/Listener set nodelay_ false; # Nagle disable?
+ 	Agent/TCP/Listener set data_on_syn_ false; # allow data on 1st SYN?
+ 	Agent/TCP/Listener set dupseg_fix_ true ; # no rexmt w/dup segs from peer
+ 	Agent/TCP/Listener set dupack_reset_ false; # exit recov on ack < highest
+ 	Agent/TCP/Listener set interval_ 0.1 ; # delayed ACK interval 100ms 
+ 	Agent/TCP/Listener set close_on_empty_ false; # close conn if sent all
+ 	Agent/TCP/Listener set signal_on_empty_ false; # signal if sent all
+ 	Agent/TCP/Listener set ts_option_size_ 10; # in bytes
+ 	Agent/TCP/Listener set reno_fastrecov_ true; # fast recov true by default
+ 	Agent/TCP/Listener set pipectrl_ false; # use "pipe" ctrl
+ 	Agent/TCP/Listener set open_cwnd_on_pack_ true; # ^ win on partial acks?
+ 	Agent/TCP/Listener set halfclose_ false; # do simplex closes (shutdown)?
+ 	Agent/TCP/Listener set nopredict_ false; # disable header prediction code?
+ }
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtiagent.tcl pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtiagent.tcl
*** new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtiagent.tcl	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtiagent.tcl	Sat Jan 31 14:52:18 2004
***************
*** 0 ****
--- 1,282 ----
+ # Special case of Agent for distributed ns simulations
+ # George F. Riley.  Georgia Tech, Fall 1998
+ 
+ # Agents on distributed ns simulations can connect to agents on 
+ # other systems, so we need some way to identify what system and
+ # what agent is desired.  The dst-ipaddr and dst-port manage this.
+ #
+ # During a "rconnect" ns command, only the local values are set, using
+ # the commands below.  They are filled in to specify dst_ as the correct
+ # border router during "$ns run" initialization
+ 
+ Agent instproc set-dst-ipaddr dstipaddr {
+     $self instvar dst_ipaddr_
+     set dst_ipaddr_ [[Simulator instance] convert-ipaddr $dstipaddr]
+     #puts "Agent $self set dstip $dst_ipaddr_"
+     #$self dbdump
+ }
+ 
+ Agent instproc ipaddr { } {
+     $self instvar dst_ipaddr_
+     #puts "Agent $self checking ipaddr"
+     if {![info exists dst_ipaddr_]} {
+         # No destination assigned
+         return 0
+     } else {
+         # exists, return actual value
+         return $dst_ipaddr_
+     }
+ }
+ 
+ Agent instproc set-dst-port dstport {
+     $self instvar dst_ipport_
+     #puts "Agent $self set dstport $dstport"
+     set dst_ipport_ $dstport
+ }
+ 
+ # Procedure to return attached node object
+ Agent instproc mynode { } {
+     $self node_
+     return $node_
+ }
+ 
+ # Manage local ip address and port
+ Agent instproc set-ipaddr { myipaddr } {
+     $self instvar my_ipaddr_
+     set my_ipaddr_ $myipaddr
+ }
+ 
+ Agent instproc myipaddr { } {
+     $self instvar my_ipaddr_
+     return $my_ipaddr_
+ }
+ 
+ Agent instproc set-port { myport } {
+     $self instvar my_port_
+     set my_port_ $myport
+ }
+ 
+ Agent instproc myport { } {
+     $self instvar my_port_
+     return $my_port_
+ }
+ 
+ # Now some special things that just apply to Agent/RTIRouter
+ 
+ # Each RTIRouter agent maintains a list of ip addresses that it can
+ # reach locally.  HACK!  Need to maintain this automatically
+ #Class Agent/RTIRouter -superclass Agent
+ Agent/RTIRouter instproc add-local-ip { localip } {
+     $self instvar ipaddr_list_
+     lappend ipaddr_list_ $localip
+     #puts "$self added local-ip [[Simulator instance] format-ipaddr $localip]"
+ }
+ 
+ # Returns TRUE if specified IP addr is local
+ Agent/RTIRouter instproc is-local-ip { whichip } {
+     $self instvar ipaddr_list_
+     #puts "Checking localip $whichip"
+     if {![info exists ipaddr_list_]} {
+         #puts "List empty"
+         return 0
+     } else {
+         # debug follows
+         #foreach i $ipaddr_list_ {
+         #    puts [format "%08x" $i]
+         #}
+         #puts "iplist is $ipaddr_list_"
+         set r [lsearch $ipaddr_list_ $whichip]
+         #puts "r is $r"
+         return [expr $r != -1 ]
+     }
+ }
+ 
+ # Each RTI Router manages a list of "RLinks" (Remote links)
+ # each of which has an associated queue,
+ # which are conceptually simplex links, with associated delays
+ # and queues.  We also put the TTLChecker here, which is a bit different
+ # than normal ns's policy of checking TTL at the receiving end.
+ # This rlinks_ list is a list of lists, as follows:
+ # {ttlcheck, queue, rtilink, ipaddr, netmask, remote-target}
+ # The remote-target field is debug only...
+ 
+ Agent/RTIRouter instproc rlink { bw delay q ipaddr netmask } {
+     $self instvar rlinks_ queue_ head_ link_ node_
+     set link_ [new RTILink]
+     $link_ set-ipaddr $ipaddr $netmask
+     $link_ set bandwidth_ $bw
+     $link_ set delay_ $delay
+ 
+     set queue_ [new Queue/$q]
+     #puts "rtirouter, queue $queue_ class is [$queue_ info class]"
+     #puts "rtirouter, link $link_   class is   [$link_ info class]"
+     $queue_ target $link_
+     set ttl_ [new TTLChecker]
+     $ttl_ target $queue_
+     if { ![info exists rlinks_] } {
+         # first rlink, make it the default
+         $self add-default-remote-route $ttl_
+     }
+     lappend rlinks_ "$ttl_ $queue_ $link_ [$link_ ipaddr] [$link_ netmask] 0"
+     set head_ $queue_
+     # Finally note the ipaddress of this node in the ipaddr list
+     $node_ set-ipaddr [$link_ ipaddr] [$link_ netmask] $link_
+ }
+ 
+ # Access the queue for a link
+ Agent/RTIRouter instproc get-queue { ipaddr } {
+     $self instvar rlinks_
+     set convip [[Simulator instance] convert-ipaddr $ipaddr]
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set thisip [lindex $l 3]
+         if { $thisip == $convip} {
+             #puts "Found rlink queue name [lindex $l 1]"
+             return [lindex $l 1]
+         }
+     }
+     puts "Can't find queue for ipaddr $ipaddr"
+     return 0
+ }
+ 
+ # For each attached link, create an RTI multicast group for data tx
+ Agent/RTIRouter instproc create-groups { } {
+     $self instvar rlinks_
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set rtilink [lindex $l 2]
+         set ipaddr [lindex $l 3]
+         $rtilink create-group $self [$rtilink broadcast-addr] $ipaddr
+     }
+ }
+ 
+ # For each attached link, publish an RTI multicast group for data tx
+ Agent/RTIRouter instproc publish-groups { } {
+     $self instvar rlinks_
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set rtilink [lindex $l 2]
+         set ipaddr [lindex $l 3]
+         $rtilink publish-group $self [$rtilink broadcast-addr] $ipaddr
+     }
+ }
+ 
+ # For each attached link, join an RTI multicast group for data tx
+ Agent/RTIRouter instproc join-groups { } {
+     $self instvar rlinks_
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set rtilink [lindex $l 2]
+         set ipaddr [lindex $l 3]
+         $rtilink join-group $self [$rtilink broadcast-addr] $ipaddr
+     }
+ }
+ 
+ Agent/RTIRouter instproc rlinks { } {
+     # Return the remote links list
+     $self instvar rlinks_
+     return $rlinks_
+ }
+ 
+ # For each attached link, find the minimum propogation delay
+ Agent/RTIRouter instproc min-lookahead { } {
+     $self instvar rlinks_
+     set mindelay 0
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set rtilink [lindex $l 2]
+         set thisdelay [$rtilink set delay_]
+         if { $i == 0} {
+             set mindelay $thisdelay
+         } else {
+             if { $thisdelay < $mindelay } {
+                 set mindelay $thisdelay
+             }
+         }
+     }
+     return $mindelay
+ }
+ 
+ # Adds a routing table as computed by route.cc
+ # n is the tcl identifier of attached node, hopcounts is 
+ # a list indexed by nodeid of hopcounts to each node
+ Agent/RTIRouter instproc add-routing-table { n hopcounts } {
+     $self instvar routetable_
+     #puts "Setting routing table for $n to $hopcounts"
+     set myid [$n id]
+     for { set i 0 } { $i < [llength $hopcounts]} { incr i} {
+         # process each node in the list
+         set hc [lindex $hopcounts $i]
+         set thisnode [[Simulator instance] get-node-by-id $i]
+         # routes.cc miscalculates hopcount to self!
+         if { $i == $myid } { set hc 0 } 
+         #puts "Node $thisnode ipaddrcnt [$thisnode ipaddrcount]"
+         if { [$thisnode ipaddrcount] != 0 } {
+             # We only need info if the target node has ip addresses
+             set ipaddrlist [$thisnode ipaddrlist]
+             foreach ip $ipaddrlist {
+                 lappend routetable_ "[lindex $ip 0] $hc"
+             }
+         }
+     }
+     if { ![info exists routetable_] } {
+         puts "$n No route table"
+     } else {
+         puts "$n routetable_ is "
+         foreach r $routetable_ {
+             puts "  [[Simulator instance] format-ipaddr [lindex $r 0]] [lindex $r 1]"
+ 
+         }
+     }
+ }
+ 
+ Agent/RTIRouter instproc get-route-table { } {
+     $self instvar routetable_
+     if { ![info exists routetable_] } {
+         return ""
+     } else {
+         return $routetable_
+     }
+ }
+ 
+ # Debug only...set the remote target.
+ # srcip identifies which remote link to connect from,
+ # targ/targip identifier which remote link to connect to
+ Agent/RTIRouter instproc rtarget { srcip targ targip } {
+     $self instvar rlinks_
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         # We need to find which link to commumicate with this target
+         if { [lindex $l 3] == $srcip} {
+             # Found it
+             #puts "Found correct ip $rlinks_"
+             # change the target entry (5th element) to correct one
+             set l [lreplace $l 5 5 $targ]
+             set rlinks_ [lreplace $rlinks_ $i $i $l]
+             # Also add a routing table entry pointing to ttl checker chain
+             $self add-route $targip [lindex $l 0]
+             # And point the rtarget of the link to the target
+             set lk [lindex $l 2]
+             $lk set-target $targ
+             return
+         }
+     }
+     puts "Could not find ip $srcip"
+ }
+     
+ # Debug only...set the route of off-system targets
+ # In the real version, this will be done by the BGP protocol
+ # targip is the off-system target ip
+ # linkip is the ipaddr of the link to route on
+ # Agent/RTIRouter instproc add-route-via { targip linkip } {
+ #     $self instvar rlinks_
+ #     set targ_ipaddr_ [[Simulator instance] convert-ipaddr $targip]
+ #     set link_ipaddr_ [[Simulator instance] convert-ipaddr $linkip]
+ #     foreach this $rlinks_ {
+ #         if { [lindex $this 3] == $link_ipaddr_ } {
+ #             $self add-route $targ_ipaddr_ [lindex $this 0]
+ #             return
+ #         }
+ #     }
+ #     puts "Error! Can't find link ipaddr [[Simulator instance] format-ipaddr $link_ipaddr_]"
+ # }
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtilink.tcl pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtilink.tcl
*** new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtilink.tcl	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtilink.tcl	Sat Jan 31 14:52:18 2004
***************
*** 0 ****
--- 1,105 ----
+ # Special case of Link for RTI interfacing
+ # George F. Riley.  Georgia Tech, Fall 1998
+ 
+ SimpleLink instproc ipaddr { } {
+   $self instvar ipaddr_
+   return $ipaddr_
+ }
+ 
+ SimpleLink instproc netmask { } {
+   $self instvar netmask_
+   return $netmask_
+ }
+ 
+ SimpleLink instproc set-ipaddr { ipaddr netmask } {
+     $self instvar ipaddr_ netmask_
+     set ipaddr_  [[Simulator instance] convert-ipaddr $ipaddr]
+     set netmask_ [[Simulator instance] convert-ipaddr $netmask]
+     #puts "SimpleLink::set-ipaddr to [[Simulator instance] format-ipaddr $ipaddr_]"
+     # And set in the nodes ip address list
+     set sn [$self src]
+     #puts "SimpleLink::set-ipaddr sn $sn"
+     $sn set-ipaddr $ipaddr_ $netmask_ $self
+     # Added by gfr to maintain C++ list of links by src->dst
+     #$self instvar link_ ; # Used only by OSC routines, not pdns
+     #$link_ set-ipaddr $ipaddr_
+ }
+ 
+ SimpleLink instproc broadcast-addr { } {
+   # Use the ipaddr and netmask to compute a broadcast addr
+     $self instvar ipaddr_ netmask_
+     set highbits [expr $ipaddr_ & $netmask_]
+     set lowbits  [expr 0xffffffff & (~$netmask_)]
+     return [expr $highbits | $lowbits]
+ }
+ 
+ #RTILinks are used only by class Agent/RTIRouter for off-system
+ #communications.
+ #Class RTILink -superclass DelayLink
+ 
+ RTILink instproc init { } {
+   $self next instvar bandwidth_ delay_ 
+   set bandwidth_ 1.5Mb
+   set delay_ 10ms
+ }
+ 
+ RTILink instproc ipaddr { } {
+   $self instvar ipaddr_
+   return $ipaddr_
+ }
+ 
+ RTILink instproc netmask { } {
+   $self instvar netmask_
+   return $netmask_
+ }
+ 
+ RTILink instproc set-ipaddr { ipaddr netmask } {
+     $self instvar ipaddr_ netmask_
+     set ipaddr_  [[Simulator instance] convert-ipaddr $ipaddr]
+     set netmask_ [[Simulator instance] convert-ipaddr $netmask]
+ }
+ 
+ RTILink instproc broadcast-addr { } {
+   # Use the ipaddr and netmask to compute a broadcast addr
+     $self instvar ipaddr_ netmask_
+     set highbits [expr $ipaddr_ & $netmask_]
+     set lowbits  [expr 0xffffffff & (~$netmask_)]
+     return [expr $highbits | $lowbits]
+ }
+ 
+ # This is a debug-only proc.  For real off-system communication,
+ # RTIKit is used
+ RTILink instproc find-peer { } {
+     foreach rp [Agent/RTIRouter info instances] {
+         if { $rp != $self } {
+             foreach rl [$rp rlinks] {
+                 # check each link
+                 if { [$rl broadcast-addr] == [$self broadcast-addr]} {
+                     # found it
+                     return $rl
+                 }
+             }
+         }
+     }
+     puts "No peer found for $self"
+     return ""
+ }
+ 
+ #RTILink instproc set-bw { bw } {
+ #    $self bandwidth_ $bw
+ #    set bandwidth_ $bw
+ #}
+ #
+ #RTILink instproc set-delay { delay } {
+ #    $self delay_ $delay
+ #    set delay_ $delay
+ #}
+ 
+ # this is debug only.  set the ns target (single system debugging only)
+ #RTILink instproc set-target { targ } {
+ #    $self instvar rtarget_
+ #    set rtarget_ $targ
+ #}
+ 
+ 
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtinode.tcl pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtinode.tcl
*** new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtinode.tcl	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtinode.tcl	Sat Jan 31 14:52:18 2004
***************
*** 0 ****
--- 1,492 ----
+ # Special case of Node for RTI interfacing
+ # George F. Riley.  Georgia Tech, Summer 1998
+ 
+ # Port management routines.  Emulate the unix "bind" option
+ # and maintain a list of agent/port tuples
+ 
+ # Locate a port in the portlist
+ # The portlist is a list of tuples, 0th is the portnum 1st is agent
+ Node instproc findport { port } {
+     $self instvar portlist_
+     if {![info exists portlist_]} {
+         # No existing ports
+         return ""
+     }
+     foreach p $portlist_ {
+         if { $port == [lindex $p 0] } {
+             # Found the correct port, return the agent id
+             return [lindex $p 1]
+         }
+     }
+     return ""
+ }
+ 
+ Node instproc find-srcport { ipaddr port } {
+     $self instvar agents_
+     #set decip [expr $ipaddr]
+     #set aip [[Simulator instance] format-ipaddr $ipaddr]
+ 
+     foreach a $agents_ {
+         set daddr 0
+         set dport -2
+         catch { set daddr [$a set dst_ipaddr_] }
+         catch { set dport [$a set dst_ipport_  ] }
+         set dip [[Simulator instance] format-ipaddr $daddr]
+         #puts "Comparing $dip to $aip and $dport to $port"
+         #if { ( [string compare $aip $dip] == 0 ) && ($dport == $port) } {
+         if { ( $ipaddr == $daddr ) && ($dport == $port) } {
+             # Found it
+             return [$a set my_port_]
+         }
+     }
+     return -1 ; # Nope, not found
+ }
+ 
+ # debug routine to dump portlist
+ Node instproc dumports { } {
+     $self instvar portlist_
+     foreach p $portlist_ {
+         puts "Agent [lindex $p 1] bound to [lindex $p 0]"
+     }
+ }
+ 
+ # Bind an agent to a particular port
+ # If port = 0, choose an available one
+ Node instproc bind { agent port } {
+     #puts "Node $self binding agent $agent to port $port"
+     $self instvar nextport_ portlist_
+     if {$port == 0} {
+         # Bind to next available port
+         if {![info exists nextport_]} {
+             # first time, set to initial value
+             set nextport_ 10000
+             #puts "Initializing nextport"
+         }
+         set thisport $nextport_
+         incr nextport_
+     } else {
+         set thisport $port
+     }
+     # Now add port/agent pair to current list
+     set existing [$self findport $thisport]
+     if { $existing != "" } {
+         puts "Can't bind to port $thisport, already bound to $existing"
+         return 0
+     }
+     lappend portlist_ " $thisport $agent "
+     # inform the agent of bound port and ipaddr
+     $agent set-port $thisport
+     $agent set-ipaddr [$self ipaddr]
+     #puts "node $self agent $agent, set port $thisport ipaddr [$self ipaddr]"
+     return $thisport
+ }
+ 
+ # Find the agent bound to a particular port on this node
+ Node instproc get-agent-by-port { port } {
+     #puts "Searching for agent at port $port"
+     $self instvar portlist_
+     if {![info exists portlist_]} {
+         return 0
+     }
+     #puts "Node $self agentportlist $portlist_"
+     # whichind is the index into the matching port/agent list
+     set whichind [lsearch $portlist_ "$port *"]
+     #puts "Whichind $whichind"
+     if {$whichind == -1} {
+         # not found
+         return 0
+     }
+     #puts "Found agent/port ind $whichind"
+     # agentport is the "port agent" pair
+     set agentport [lindex $portlist_ $whichind]
+     return [lindex $agentport 1]
+ }
+ 
+ # For distributed ns, nodes have the concept of "ip address".
+ # Actually IP addresses are assigned to links, so the node just
+ # gets a list of IP addresses, matching the addresses of the connected
+ # links.  Also stores the netmask (useless I think!) and the node name of
+ # connected link.
+ 
+ Node instproc set-ipaddr { ipaddr netmask whichlink } {
+     $self instvar ipaddrlist_
+     #puts "Node $self adding ipaddr [[Simulator instance] format-ipaddr $ipaddr]"
+     set ipa [[Simulator instance] convert-ipaddr $ipaddr]
+     lappend ipaddrlist_ "$ipa $netmask $whichlink"
+     catch {
+         #puts "Node $self setting ipa [[Simulator instance] format-ipaddr $ipa]"
+         [[Simulator instance] set scheduler_] add-local-ip $ipa $self
+     }
+ 		# Assign local ip to all agents if they don't already have one
+ 		$self instvar agents_
+ 		foreach a $agents_ {
+ 		    set myip [$a set my_ipaddr_]
+ 		    if { $myip == 0} {
+ 		         puts "Node $self found agent $a without ip, assigning $ipaddr"
+ 			       $a set my_ipaddr_ $ipaddr
+ 			  }
+ 		}
+ }
+ 
+ # Returns the first value in the ipaddr list
+ Node instproc ipaddr { } {
+     $self instvar ipaddrlist_
+     if {![info exists ipaddrlist_]} {
+         $self instvar address_
+         return $address_ ; # Return the address if no ipaddrlist
+     }
+     set first [lindex $ipaddrlist_ 0]
+     return [lindex $first 0]
+ }
+ 
+ Node instproc ipaddrlist { } {
+     $self instvar ipaddrlist_
+     return $ipaddrlist_
+ }
+ 
+ # Returns the number of ipaddresses in a node's list
+ Node instproc ipaddrcount { } {
+     $self instvar ipaddrlist_
+     if {![info exists ipaddrlist_]} {
+         return 0
+     }
+     return [llength $ipaddrlist_]
+ }
+ 
+ # Determines if a given node matches the specified IP address
+ Node instproc ipmatch { whichip } {
+     $self instvar ipaddrlist_
+     #puts "Checking ipmatch for node $self against $whichip"
+     if {![info exists ipaddrlist_]} {
+         # No ip addresses for this node, can't possibly match
+         return 0;
+     }
+     #puts "IPAddrList $ipaddrlist_"
+     set formattedip [[Simulator instance] convert-ipaddr $whichip]
+     set whichind [lsearch $ipaddrlist_ "$formattedip * *"]
+     if {$whichind == -1} {
+         # Not in list, return false
+         return 0;
+     } else {
+         return 1;  
+     }
+ }
+ 
+ # Returns the iplist list for the specified ip address
+ Node instproc ipinfo { whichip } {
+     $self instvar ipaddrlist_
+     set formattedip [[Simulator instance] convert-ipaddr $whichip]
+     set whichind [lsearch $ipaddrlist_ "$formattedip * *"]
+     if {$whichind == -1} {
+         # Not in list, return junk
+         return { 0 0 ""}
+     } else {
+         return [lindex $ipaddrlist_ $whichind]
+     }
+ }
+ 
+ 
+ # Distributed ns has a default route for each node.  If no
+ # default route is defined for a node, then the global default
+ # route is used
+ Node instproc add-route-default { rtidefaultroute } {
+     $self instvar default_route_ rtirouter_
+     set default_route_ [$rtidefaultroute set rtirouter_]
+     #puts "Added default route [$rtidefaultroute set rtirouter_] for node $self"
+ }
+ 
+ Node instproc default-route { } {
+     $self instvar default_route_
+     if {![info exists default_route_]} {
+         # No node specific default route, return system default
+         #puts "No default route for node $self, checking default-default"
+         return [[Simulator instance] default-route]
+     } else {
+         return $default_route_  
+     }
+ }
+ 
+ # Allows a node to specify it would like the routing table
+ # computed by routes.cc.  "$node set NeedRoutes 1" says you 
+ # want them
+ Node instproc NeedRoutes? { } {
+     $self instvar NeedRoutes
+     return [info exists NeedRoutes]
+ }
+ 
+ Node instproc SetRoutes { routelist } {
+     #puts "$self ([$self id]) got routelist $routelist"
+     # First find if we have an Agent/RTIRouter on this node
+     # If not, just ignore
+     $self instvar agents_
+     if {[llength $agents_] == 0} {
+         #puts "No agents on node $self, exiting"
+         return
+     }
+     foreach agent $agents_ {
+         if { [$agent info class] == "Agent/RTIRouter" } {
+             #puts "Found RTIRouter ($agent) on $self"
+             $agent add-routing-table $self $routelist
+             return
+         }
+     }
+     #puts "No RTIRouter found on $self"
+ }
+ 
+ # The following to manage rlinks are moved from Agent/RTIRouter
+ # It makes more sense for the rlinks to be a function of nodes, not agents
+ # Each edge node  manages a list of "RLinks" (Remote links)
+ # each of which has an associated queue,
+ # which are conceptually simplex links, with associated delays
+ # and queues.  We also put the TTLChecker here, which is a bit different
+ # than normal ns's policy of checking TTL at the receiving end.
+ # This rlinks_ list is a list of lists, as follows:
+ # {ttlcheck, queue, rtilink, ipaddr, netmask, remote-target}
+ # The remote-target field is debug only...
+ # This instproc returns the actual RTILink object
+ Node instproc rlink { bw delay q ipaddr netmask } {
+     #puts "Node::rlink bw $bw delay $delay"
+     $self instvar rlinks_ queue_ link_ node_ rtirouter_
+     set link_ [new RTILink]
+     $link_ set-ipaddr $ipaddr $netmask
+     $link_ set bandwidth_ $bw
+     $link_ set delay_ $delay
+ 
+     set queue_ [new Queue/$q]
+     #puts "rtirouter, queue $queue_ class is [$queue_ info class]"
+     #puts "rtirouter, link $link_   class is   [$link_ info class]"
+     $queue_ target $link_
+     set ttl_ [new TTLChecker]
+     $ttl_ target $queue_
+     if {![info exists rtirouter_] } {
+         # Need to create the RTIRouter for this node
+         set rtirouter_ [new Agent/RTIRouter]
+         [Simulator instance] attach-agent $self $rtirouter_
+         #puts "Node $self created rtirouter_ $rtirouter_"
+     }
+     if { ![info exists rlinks_] } {
+         # first rlink, make it the default
+         $rtirouter_ add-default-remote-route $ttl_
+     }
+     lappend rlinks_ "$ttl_ $queue_ $link_ [$link_ ipaddr] [$link_ netmask] 0"
+     $link_ set head_ $queue_
+     # Finally note the ipaddress of this node in the ipaddr list
+     $self set-ipaddr [$link_ ipaddr] [$link_ netmask] $link_
+     return $link_
+ }
+ 
+ # Access the queue for a remote link
+ Node instproc get-rqueue { ipaddr } {
+     $self instvar rlinks_
+     set convip [[Simulator instance] convert-ipaddr $ipaddr]
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set thisip [lindex $l 3]
+         if { $thisip == $convip} {
+             #puts "Found rlink queue name [lindex $l 1]"
+             return [lindex $l 1]
+         }
+     }
+     puts "Can't find queue for ipaddr $ipaddr"
+     return 0
+ }
+ 
+ # For each attached link, create an RTI multicast group for data tx
+ Node instproc create-groups { } {
+     $self instvar rlinks_ rtirouter_
+     if {! [info exists rlinks_] } {
+         return ; # No rlinks, nothing to do
+     }
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set rtilink [lindex $l 2]
+         set ipaddr [lindex $l 3]
+         set bc [$rtilink broadcast-addr]
+         $rtilink create-group $rtirouter_ $bc $ipaddr
+     }
+ }
+ 
+ # For each attached link, publish an RTI multicast group for data tx
+ Node instproc publish-groups { } {
+     $self instvar rlinks_ rtirouter_
+     if {! [info exists rlinks_] } {
+         return ; # No rlinks, nothing to do
+     }
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set rtilink [lindex $l 2]
+         set ipaddr [lindex $l 3]
+         set bc [$rtilink broadcast-addr]
+         $rtilink publish-group $rtirouter_ $bc $ipaddr
+     }
+ }
+ 
+ # For each attached link, join an RTI multicast group for data tx
+ Node instproc join-groups { } {
+     $self instvar rlinks_ rtirouter_
+     if {! [info exists rlinks_] } {
+         return ; # No rlinks, nothing to do
+     }
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set rtilink [lindex $l 2]
+         set ipaddr [lindex $l 3]
+         set bc [[Simulator instance] format-ipaddr [$rtilink broadcast-addr]]
+         $rtilink join-group $rtirouter_ $bc $ipaddr
+     }
+ }
+ 
+ Node instproc rlinks { } {
+     # Return the remote links list
+     $self instvar rlinks_
+     return $rlinks_
+ }
+ 
+ # For each attached link, find the minimum propogation delay
+ Node instproc min-lookahead { } {
+     $self instvar rlinks_
+     if {! [info exists rlinks_] } {
+         return 999999; # No rlinks, use large lookahead
+     }
+     set mindelay 0
+     for { set i 0 } { $i < [llength $rlinks_] } {incr i} {
+         set l [lindex $rlinks_ $i]
+         set rtilink [lindex $l 2]
+         set thisdelay [$rtilink set delay_]
+         if { $i == 0} {
+             set mindelay $thisdelay
+         } else {
+             if { $thisdelay < $mindelay } {
+                 set mindelay $thisdelay
+             }
+         }
+     }
+     return $mindelay
+ }
+ 
+ # Debug only...set the route of off-system targets
+ # In the final version, this will be done by the BGP protocol
+ # targip is the off-system target ip
+ # linkip is the ipaddr of the link to route on
+ # If a target mask is specified, the routes are aggregated with the
+ #   mask specified.  This allows all ip addresses beginning with a prefix
+ #   to be routed via the same link.
+ Node instproc add-route-via { targip linkip { targmask 0xffffff00 } } {
+     #$self instvar rlinks_ rtirouter_
+     #set targ_ipaddr_ [[Simulator instance] convert-ipaddr $targip]
+     #set link_ipaddr_ [[Simulator instance] convert-ipaddr $linkip]
+     #foreach this $rlinks_ {
+     #    if { [lindex $this 3] == $link_ipaddr_ } {
+     #        $rtirouter_ add-route $targ_ipaddr_ [lindex $this 0] \
+     #            [[Simulator instance] convert-ipaddr $targmask]
+     #        return
+     #    }
+     #}
+     #puts "Error! Can't find link ipaddr [[Simulator instance] format-ipaddr $link_ipaddr_]"
+ 
+     # ALFRED use add-route-via-src below instead with defaults:
+     #    srcip 0.0.0.0 and srcmask 0.0.0.0
+     $self add-route-via-src $targip $targmask 0.0.0.0 0.0.0.0 $linkip
+ }
+ 
+ # ALFRED add add-route-via-src support
+ Node instproc add-route-via-src { dst dm src sm targ } {
+   $self instvar rlinks_ rtirouter_
+   set dstip [[Simulator instance] convert-ipaddr $dst]
+   set dmask [[Simulator instance] convert-ipaddr $dm]
+   set srcip [[Simulator instance] convert-ipaddr $src]
+   set smask [[Simulator instance] convert-ipaddr $sm]
+   set rip [[Simulator instance] convert-ipaddr $targ]
+   foreach this $rlinks_ {
+     if { [lindex $this 3] == $rip } {
+       $rtirouter_ add-route $srcip $smask $dstip $dmask [lindex $this 0]
+       return
+     }
+   }
+   puts "Node($self): Warning! Can't find $targ link!"
+ }
+ 
+ Node instproc unattach { a } {
+     # Delete's an entry from the agents list
+     $self instvar agents_
+     set i [lsearch $agents_ $a]
+     if { $i >= 0} {
+         if { $i == 0 } {
+             # delete first
+             set agents_ [lrange $agents_ 1 end]
+         } else {
+             set im1 [expr $i - 1]
+             set ip1 [expr $i + 1]
+             set agents_ [concat [lrange $agents_ 0 $im1] \
+                                 [lrange $agents_ $ip1 end] ]
+         }
+     }
+ }
+ 
+ Node instproc exchange-routes { } {
+     # Run the run-time route exchange (not coded yet)
+     $self instvar rtirouter_
+     if { [info exists rtirouter_] } {
+         $rtirouter_ exchange-routes
+     }
+ }
+ 
+ # ALFRED add droptarget support
+ Node instproc get-droptarget { } {
+   $self instvar dt_
+   if {![info exists dt_]} {
+     set dt_ [new DropTargetAgent]
+     [Simulator instance] attach-agent $self $dt_
+   }
+   return $dt_
+ }
+ 
+ # The following are leftover from the original hack implementation
+ # and no longer of value
+ # Node instproc set-input-port inport {
+ #   $self instvar inport_
+ #   set inport_ $inport
+ # }
+ 
+ # Node instproc set-output-port outport {
+ #   $self instvar outport_
+ #   set outport_ $outport
+ # }
+ 
+ # Node instproc create-groups { } {
+ #   $self instvar outport_
+ #   if { [info exists outport_] } {
+ #       #puts "Node $self outport_ $outport_"
+ #       set rt [Agent/RTI info instances]
+ #       #puts "Number RTIAgents is [llength $rt]"
+ #       set na [llength $rt]
+ #       # HACK!  Need to code for multiple RTI Agents
+ #       if {$na == 1} {
+ #           #puts "rt $rt"
+ #           #set rti [lindex $rt 1]
+ #           #puts "creating group agent $rti port $outport_"
+ #           $rt create-group $outport_ $self
+ #       }
+ #   } else {
+ #       #puts "Node $self no outport"
+ #   }
+ # }
+ 
+ # Node instproc join-groups { } {
+ #   $self instvar inport_
+ #   if { [info exists inport_] } {
+ #       # puts "Node $self inport_ $inport_"
+ #       set rt [Agent/RTI info instances]
+ #       # puts "Number RTIAgents is [llength $rt]"
+ #       set na [llength $rt]
+ #       # HACK!  Need to code for multiple RTI Agents
+ #       if {$na == 1} {
+ #           #set rti [lindex $rt 1]
+ #           $rt join-group $inport_ $self
+ #       }
+ #   } else {
+ #       #puts "Node $self no inport"
+ #   }
+ # }
+ 
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtisim.tcl pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtisim.tcl
*** new_p/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtisim.tcl	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcl/rti/ns-rtisim.tcl	Sat Jan 31 14:52:18 2004
***************
*** 0 ****
--- 1,250 ----
+ # Some extra simulator commands for distributed ns processing
+ # George F. Riley.  Georgia Tech, Fall 1998
+ 
+ # Used for timing tests...logs actual start of simulation (after all RTI init)
+ Simulator instproc sim-start { } {
+     global simstart
+     set simstart [clock seconds]
+ }
+ 
+ # In distributed ns, connections can be from a source node to a 
+ # non-local "ipaddress/port" pair.
+ Simulator instproc rconnect { src dstipaddr dstport } {
+   #puts "Simulator rconnect src $src dstip $dstipaddr $dstport"
+   $src set-dst-ipaddr $dstipaddr
+   $src set-dst-port   $dstport
+   # Following code obviates the "complete-remote-connections" stuff
+   set thisnode [$src set node_]
+   set defaultroute [$thisnode default-route]
+   if { $defaultroute != "" } {
+       $self connect $src $defaultroute
+   }
+   #puts "Sim::rconnect src $src defr $defaultroute"
+ }
+ 
+ # ALFRED ip-connect, alternative/replacement to rconnects
+ Simulator instproc ip-connect { src dstipaddr dstport } {
+   $self instvar scheduler_
+   set localnode [$scheduler_ get-local-ip $dstipaddr]
+   set remotepath [$scheduler_ get-iproute $src $dstipaddr]
+   #puts "localnode $localnode remotepath $remotepath"
+   # local connect
+   if {$localnode != 0 && $remotepath == 0} {
+     set localagent [$localnode findport $dstport]
+     if {$localagent != ""} {
+       $self connect $src $localagent
+       $src set-dst-ipaddr $dstipaddr
+       $src set-dst-port   $dstport
+       #puts [format "%.6f: Sim::ip-connect: lconnect $src -> $localagent ($dstipaddr:$dstport)" [$self now]]
+     } else {
+       puts [format "%.6f: Sim::ip-connect: FATAL: cannot find local agent for $dstipaddr:$dstport" [$self now]]
+     }
+   } else {
+     # set connect now
+     $scheduler_ iproute-connect $src $dstipaddr $dstport
+     # remote connect
+     $src set-dst-ipaddr $dstipaddr
+     $src set-dst-port   $dstport
+     #puts [format "%.6f: Sim::ip-connect: rconnect $src -> $dstipaddr:$dstport" [$self now]]
+   }
+ }
+ 
+ # ALFRED add single command to aggregate route-via/pt/iproute together
+ Simulator instproc add-route { 
+   router rip dst dmask { src 0.0.0.0 } { smask 0.0.0.0 } } {
+   
+   $self instvar scheduler_
+   set ragent [$router set rtirouter_]
+   $router add-route-via-src $dst $dmask $src $smask $rip
+   $ragent add-route-passthrough $dst $dmask $src $smask $rip
+   $scheduler_ add-iproute $dst $dmask $src $smask $ragent
+ }
+ 
+ #Simulator instproc is-local-ip { whichip } {
+ #    foreach this [Agent/RTIRouter info instances] {
+ #        if { $this is-local-ip $whichip } { return 1 } ; # found it
+ #    }
+ #    return 0; # Not found
+ #}
+ 
+ Simulator instproc add-local-ip { whichip node } {
+     instvar scheduler_
+     $scheduler_ add-local-ip $whichip $node ; # Scheduler does this
+     # since there is a .cc for the scheduler that uses stl to track
+     # IPAddress vs. ns Node.
+ }
+ 
+ Simulator instproc lookup-srcport { ipaddr daddr dport } {
+     $self instvar scheduler_
+     set n [$scheduler_ get-local-ip $ipaddr]
+     if {$n == 0} { return 0 }
+     foreach a [$n set agents_] {
+         # Each agent assigned to n
+         if { ([$a set dst_ipaddr_] == $daddr) &&
+              ([$a set dst_ipport_] == $dport) } {
+             # Found it
+             return [$a set src_ipport_]
+         }
+     }
+     return 0 ; # Nope, can't find it
+ }
+ 
+ # DEBUG ROUTINE ONLY...used for testing distns in single system
+ Simulator instproc debug-connect { src srcip dst dstip } {
+     if {[$src info class] != "Agent/RTIRouter" ||
+         [$dst info class] != "Agent/RTIRouter" } {
+         puts "ERROR! debug-connect must connect RTIRouters"
+         return;
+     }
+     set ns [Simulator instance]
+     $src rtarget [$ns convert-ipaddr $srcip] $dst [$ns convert-ipaddr $dstip]
+     $dst rtarget [$ns convert-ipaddr $dstip] $src [$ns convert-ipaddr $srcip]
+ }
+ 
+ # For debugging/timing testing only
+ # Determines of a forced-lookahead vlue is set
+ Simulator instproc forced-lookahead { } {
+     $self instvar forced-lookahead-value
+     return [info exists forced-lookahead-value]
+ }
+ 
+ # Calculates the lookahead value for this sim.
+ # The lookahead is the minimum of the propagation delay for all rlinks
+ Simulator instproc get-lookahead { } {
+     set first 1
+     set currentmin 0
+     set nodelist [Node info instances]
+     if { [ llength $nodelist ] == 0 } {
+         # Try NixNodes
+         set nodelist [Node/NixNode info instances]
+     }
+     foreach this $nodelist {
+         set thismin [$this min-lookahead]
+         #puts "Min from $this is $thismin"
+         if { $first } {
+             set currentmin $thismin
+             set first 0
+         } else {
+             if {$thismin < $currentmin} {
+                 set currentmin $thismin
+             }
+         }
+     }
+     return $currentmin
+ }
+ 
+ # Specifies the "default default" router.
+ Simulator instproc add-route-default { rtidefaultroute } {
+     $self instvar default_route_
+     set default_route_ [$rtidefaultroute set rtirouter_]
+ }
+ 
+ Simulator instproc default-route { } {
+     $self instvar default_route_
+     if {![info exists default_route_]} {
+         return ""
+     } else {
+         return $default_route_  
+     }
+ }
+ 
+ Simulator instproc complete-remote-connections { } {
+     #puts "Simulator::complete-remote-connections"
+     set nodelist [Node info instances]
+     if { [ llength $nodelist ] == 0 } {
+         # Try NixNodes
+         set nodelist [Node/NixNode info instances]
+     }
+     foreach thisnode $nodelist {
+         #puts "Processing completions node $thisnode"
+         foreach a [$thisnode set agents_] {
+             #puts "Processing agent $a"
+             set dstip [$a ipaddr]
+             if { $dstip != 0 } {
+                 # found a remote connection
+                 #puts "Found remote connection to [[Simulator instance] format-ipaddr $dstip]"
+                 set defaultroute [$thisnode default-route]
+                 if { $defaultroute == "" } {
+                     puts "No default route, skipping $a [[Simulator instance] format-ipaddr $dstip]"
+                 } else {
+                     # create an ns connection to the default router
+                     # DEBUG! Need to find best route
+                     $self connect $a $defaultroute
+                     #puts "Connecting to $defaultroute"
+                 }
+             }
+         }
+     }
+ }
+ 
+ Simulator instproc convert-ipaddr ipaddr {
+     set c [regsub -all \\. $ipaddr " " addrlist]
+     if { $c == 0} { 
+         return [expr $ipaddr]
+     }
+     if { [llength $addrlist] != 4} {
+         puts "Ill-formatted ip address $ipaddr, addrlistlth = [llength $addrlist]"
+         return 0
+     }
+     if { $c == 3 } {
+         set r 0
+         foreach a $addrlist {
+             if { $a < 0 || $a > 255 } {
+                 puts "Ill-formatted ip address $ipaddr, a = $a"
+                 return 0
+             }
+             set r [expr ($r << 8) + $a]     
+             # puts [format "inloop r is %02x %02x" $r $a]
+         }
+         return $r
+     } else {
+         puts "Ill-formatted ip address $ipaddr, c = $c"
+         return 0
+     }
+ }
+ 
+ Simulator instproc format-ipaddr ipaddr {
+     set p1 [expr ($ipaddr >> 24) & 0xff]
+     set p2 [expr ($ipaddr >> 16) & 0xff]
+     set p3 [expr ($ipaddr >>  8) & 0xff]
+     set p4 [expr ($ipaddr >>  0) & 0xff]
+     return [format "%d\.%d\.%d\.%d" $p1 $p2 $p3 $p4]
+ }
+ 
+ # Locates the matching node for a specified ip address
+ Simulator instproc find-node-by-ip ipaddr {
+     $self instvar Node_
+     # nn is next available node index
+     set nn [Node set nn_]
+     for {set i 0} {$i < $nn} {incr i} {
+         set n $Node_($i)
+         # n is the node
+         if {[$n ipmatch $ipaddr]} {
+             # Found it
+             return $n
+         }
+     }
+     # Not found
+     return 0
+ }
+ 
+ # Get the queue associated with an rlink
+ Simulator instproc rqueue { n1 addr } {
+     # ALFRED - bug fix (comment next 4 lines)
+     #$self instvar Node_
+     #if { ![catch "$n1 info class Node"] } {
+     #    set n1 [$n1 id]
+     #}
+     return [$n1 get-rqueue $addr]
+ }
+ 
+ Simulator instproc log-simstart { } {
+         # GFR Modification to log actual start
+         global simstart
+         puts "Starting Actual Simulation"
+         set simstart [clock seconds]
+ }
+ 
+ Simulator instproc unattach-agent { n a } {
+     $n unattach $a
+ }
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcp/tcp-full.cc pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/tcp-full.cc
*** new_p/ns-allinone-2.27/ns-2.27/tcp/tcp-full.cc	Wed Jan 28 20:49:40 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/tcp-full.cc	Sat Jan 31 14:51:17 2004
***************
*** 397,402 ****
--- 397,403 ----
  void
  FullTcpAgent::sendmsg(int nbytes, const char *flags)
  {
+   if (dResetFlag) return; // KALYAN patch
  	if (flags && strcmp(flags, "MSG_EOF") == 0) 
  		close_on_empty_ = TRUE;	
  	if (flags && strcmp(flags, "DAT_EOF") == 0) 
***************
*** 808,813 ****
--- 809,815 ----
  void
  FullTcpAgent::sendpacket(int seqno, int ackno, int pflags, int datalen, int reason)
  {
+   if (dResetFlag) return; // KALYAN patch
          Packet* p = allocpkt();
          hdr_tcp *tcph = hdr_tcp::access(p);
  	hdr_flags *fh = hdr_flags::access(p);
***************
*** 1162,1167 ****
--- 1164,1170 ----
  //printf("%f: send_much(f:%d, win:%d, pipectrl:%d, pipe:%d, t_seqno:%d, topwin:%d, maxseq_:%d\n",
  //now(), force, win, pipectrl_, pipe_, int(t_seqno_), topwin, int(maxseq_));
  
+   if (dResetFlag) return; // KALYAN patch
  	if (!force && (delsnd_timer_.status() == TIMER_PENDING))
  		return;
  
***************
*** 1461,1466 ****
--- 1464,1476 ----
  //prpkt(pkt);
  //}
  
+   // Process RST, KALYAN patch
+   if (tiflags & TH_RST) {
+     fprintf(stderr, "%f: FullTcp(%s): recv'd reset\n", now(), name());
+     dResetFlag = 1;
+     goto drop;
+   }
+ 
  	/*
  	 * Don't expect to see anything while closed
  	 */
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcp/tcp-full.h pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/tcp-full.h
*** new_p/ns-allinone-2.27/ns-2.27/tcp/tcp-full.h	Wed Jan 28 20:49:40 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/tcp-full.h	Sat Jan 31 14:51:17 2004
***************
*** 95,100 ****
--- 95,101 ----
   
  #define TH_FIN  0x01        /* FIN: closing a connection */
  #define TH_SYN  0x02        /* SYN: starting a connection */
+ #define TH_RST  0x04        /* RST: reset connection */ // KALYAN patch
  #define TH_PUSH 0x08        /* PUSH: used here to "deliver" data */
  #define TH_ACK  0x10        /* ACK: ack number is valid */
  #define TH_ECE  0x40        /* ECE: CE echo flag */
***************
*** 120,126 ****
          	last_send_time_(-1.0), infinite_send_(FALSE), irs_(-1),
          	delack_timer_(this), flags_(0),
          	state_(TCPS_CLOSED), ect_(FALSE), recent_ce_(FALSE),
!         	last_state_(TCPS_CLOSED), rq_(rcv_nxt_), last_ack_sent_(-1) { }
  
  	~FullTcpAgent() { cancel_timers(); rq_.clear(); }
  	virtual void recv(Packet *pkt, Handler*);
--- 121,128 ----
          	last_send_time_(-1.0), infinite_send_(FALSE), irs_(-1),
          	delack_timer_(this), flags_(0),
          	state_(TCPS_CLOSED), ect_(FALSE), recent_ce_(FALSE),
!         	last_state_(TCPS_CLOSED), rq_(rcv_nxt_), last_ack_sent_(-1),
!           dResetFlag(0) { }
  
  	~FullTcpAgent() { cancel_timers(); rq_.clear(); }
  	virtual void recv(Packet *pkt, Handler*);
***************
*** 160,165 ****
--- 162,168 ----
  	int nopredict_;	    // disable header predication
  	int dsack_;	    // do DSACK as well as SACK?
  	double delack_interval_;
+   int dResetFlag; // KALYAN patch
  
  	int headersize();   // a tcp header w/opts
  	int outflags();     // state-specific tcp header flags
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcp/tcp-listener.cc pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/tcp-listener.cc
*** new_p/ns-allinone-2.27/ns-2.27/tcp/tcp-listener.cc	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/tcp-listener.cc	Sat Jan 31 14:51:17 2004
***************
*** 0 ****
--- 1,973 ----
+ /* Tcp Listener Agent :: for dynamic FullTcp connections
+  * 
+  * Alfred Park (park@cc.gatech.edu)
+  * College of Computing, Georgia Institute of Technology
+  *
+  * *** Revision History ***
+  * v0.84 (01/28/04): add local->remote->local fixes, bug fixes
+  * v0.83 (05/29/03): small optimizations and extra checks added
+  * v0.82 (05/24/03): fixed timeout bugs and removed unnecessary reschedules,
+  *                   added init parameters support for application binding
+  * v0.81 (05/21/03): fixed filter trigger/release bugs
+  * v0.8  (05/20/03): added FullTcpAgent prebinding support
+  * v0.71 (05/19/03): fixed iss_, cwnd_, and connection expire bugs
+  * v0.7  (05/17/03): application binding support, cmap_ optimizations
+  * v0.6  (05/16/03): pdns-2.26-v2 "ip-connect" compatibility
+  * v0.5  (05/14/03): NetAnim tracefile support added
+  * v0.4  (05/02/03): more syn+ack bugs fixed, egress filtering support added
+  * v0.3  (04/11/03): syn+ack retry bugs fixed, improved efficiency
+  * v0.2  (04/10/03): expiration timer added for non syn+ack retry listeners
+  * v0.1  (04/04/03): added syn+ack timeout mechanism, spawned FullTcpAgents 
+  *                   inherit attributes from listener, optimizations added
+  * v0.0  (04/01/03): initial release
+  */
+ 
+ #include "ip.h"
+ #include "flags.h"
+ #include "random.h"
+ #include "tcp-listener.h"
+ #include "tclcl.h"
+ #include "rti/rtisched.h"
+ #ifdef HAVE_FILTER
+ #include "rti/rtioob.h"
+ #endif
+ 
+ // Need prototypes from rtisched.cc 
+ NsObject* GetLocalIP(ipaddr_t ipaddr);
+ Agent *GetIPRoute(ipaddr_t ipaddr, ipaddr_t srcip);
+ 
+ static class TcpListenerClass : public TclClass {
+   public:
+     TcpListenerClass() : TclClass("Agent/TCP/Listener") {}
+     TclObject* create(int, const char*const*) {
+       return (new TcpListenerAgent());
+     }
+ } listener_class;
+ 
+ TcpListenerAgent::TcpListenerAgent() : ltimer_(this) {
+   connections_ = 0;
+   state_ = TCPS_LISTEN;
+   type_ = PT_ACK;
+   pNode = NULL;
+   filter_on_ = false;
+   trace_file_ = NULL;
+   trace_pktcount_ = 0;
+   trace_prefix_ = NULL;
+   app_agent_ = NULL;
+   app_params_ = NULL;
+   app_callback_ = NULL;
+   app_recv_ = 0;
+   app_reuse_ = 0;
+   app_pApp_ = NULL;
+   fulltcp_num_ = 0;
+   fulltcp_len_ = 0;
+   fulltcp_use_ = 0;
+   current_to_ = 0.0;
+ }
+ 
+ void TcpListenerAgent::delay_bind_init_all() {
+ 
+   delay_bind_init_one("max_synack_retries_");
+   delay_bind_init_one("table_size_");
+   delay_bind_init_one("entry_expire_");
+   delay_bind_init_one("filter_enable_");
+   delay_bind_init_one("filter_trigger_");
+   delay_bind_init_one("filter_release_");
+   delay_bind_init_one("trace_enable_");
+   delay_bind_init_one("trace_interval_");
+   delay_bind_init_one("prebinding_");
+   FullTcpAgent::delay_bind_init_all();
+   reset();
+ }
+ 
+ int TcpListenerAgent::delay_bind_dispatch(const char *varName, 
+     const char *localName, TclObject *tracer) {
+   
+   if (delay_bind(varName, localName, "max_synack_retries_", 
+         &max_synack_retries_, tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "table_size_", &table_size_, tracer))
+     return TCL_OK;
+   if (delay_bind(varName, localName, "entry_expire_", &entry_expire_, 
+         tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "filter_enable_", &filter_enable_, 
+         tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "filter_trigger_", &filter_trigger_, 
+         tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "filter_release_", &filter_release_, 
+         tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "trace_enable_", &trace_enable_, 
+         tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "trace_interval_", &trace_interval_, 
+         tracer)) return TCL_OK;
+   if (delay_bind(varName, localName, "prebinding_", &prebinding_, 
+         tracer)) return TCL_OK;
+   return FullTcpAgent::delay_bind_dispatch(varName, localName, tracer);
+ }
+ 
+ int TcpListenerAgent::command(int argc, const char*const* argv) {
+   
+   if (argc == 2) {
+     if (strcmp(argv[1], "reset") == 0) {
+       reset_state();
+       return (TCL_OK);
+     }
+   }
+   if (argc == 3) {
+     if (strcmp(argv[1], "add-fulltcp") == 0) {
+       if (fulltcp_num_ == 0) {
+         if ((fulltcp_ = (Agent **)malloc(sizeof(Agent *) * 100)) == NULL) {
+           printf("TcpListenerAgent(%s): FATAL: add-fulltcp malloc() failed!\n",
+               name());
+           exit(1);
+         }
+         fulltcp_len_ += 100;
+       } else if (fulltcp_num_ >= fulltcp_len_) {
+         Agent **tmp;
+         if ((tmp = (Agent **)realloc(fulltcp_, sizeof(Agent *) *
+                 (fulltcp_len_ + 100))) == NULL) {
+           printf("TcpListenerAgent(%s): FATAL: add-fulltcp realloc() failed!\n",
+               name());
+           exit(1);
+         }
+         fulltcp_ = tmp;
+         fulltcp_len_ += 100;
+       }
+       fulltcp_[fulltcp_num_] = (Agent *)TclObject::lookup(argv[2]);
+       if (fulltcp_[fulltcp_num_] == NULL) {
+         printf("TcpListenerAgent(%s): FATAL: add-fulltcp lookup(%s) failed!\n",
+             name(), argv[2]);
+         exit(1);
+       }
+       fulltcp_num_++;
+       return (TCL_OK);
+     }
+     if (strcmp(argv[1], "set-tracefile") == 0) {
+       if (trace_enable_ > 0) {
+         trace_file_ = strdup(argv[2]);
+         if ((trace_fp_ = fopen(trace_file_, "w")) == NULL) {
+           printf("%f: TcpListenerAgent(%s): cannot open tracefile (%s)\n",
+               now(), name(), trace_file_);
+           printf("  for writing. Disabling tracefile output.\n");
+           trace_enable_ = 0;
+         } else {
+           fclose(trace_fp_);
+         }
+         if (trace_prefix_ == NULL) {
+           printf("%f: TcpListenerAgent(%s): Warning: trace_prefix_ is NULL\n", 
+               now(), name());
+           trace_prefix_ = strdup("!");
+         }
+       }
+       return (TCL_OK);
+     }
+     if (strcmp(argv[1], "set-traceprefix") == 0) {
+       if (trace_prefix_ != NULL)
+         free(trace_prefix_);
+       trace_prefix_ = strdup(argv[2]);
+       return (TCL_OK);
+     }
+   }
+   if (argc == 7) {
+     if (strcmp(argv[1], "set-application") == 0) {
+       app_agent_ = strdup(argv[2]);
+       app_params_ = strdup(argv[3]);
+       app_callback_ = strdup(argv[4]);
+       app_recv_ = atoi(argv[5]);
+       app_reuse_ = atoi(argv[6]);
+       return (TCL_OK);
+     }
+   }
+   return (TcpAgent::command(argc, argv));
+ }
+ 
+ void TcpListenerAgent::reset_state() {
+ 
+   closed_ = 0;
+   pipe_ = -1;
+   rtxbytes_ = 0;
+   fastrecov_ = FALSE;
+   last_send_time_ = -1.0;
+   infinite_send_ = FALSE;
+   irs_ = -1;
+   maxseq_ = -1;
+   flags_ = 0;
+   ect_ = FALSE;
+   recent_ce_ = FALSE;
+   last_ack_sent_ = -1;
+   cancel_timers();
+   rq_.clear();
+   reset();
+   last_state_ = TCPS_CLOSED;
+   state_ = TCPS_LISTEN;
+   type_ = PT_ACK;
+ }
+ 
+ void TcpListenerAgent::add_connection(ipaddr_t src_ip, ipportaddr_t sport) {
+ 
+   ip_info_t *ip_info = new ip_info_t;
+   ip_info->pAgent = NULL;
+   ip_info->connect_time = now();
+   ip_info->est = false;
+ 
+   cmap_.insert(cmap_pt(cmap_kt(src_ip, sport), ip_info));
+   connections_++;
+ 
+   if (debug_ > 2) {
+     printf("%f: TcpListenerAgent(%s): cmap_ list:\n", now(), agent_name);
+     for (cmap_it it = cmap_.begin(); it != cmap_.end(); it++)
+       printf("  srcip %08x sport %d ct %f\n", ((*it).first).first,
+           ((*it).first).second, ((*it).second)->connect_time);
+   }
+   // Trace this data to out file
+   if (trace_enable_ > 0) {
+     trace_pktcount_ = 0;
+     if ((trace_fp_ = fopen(trace_file_, "a")) == NULL) {
+       printf("%f: TcpListenerAgent(%s): cannot open tracefile (%s)\n",
+           now(), agent_name, trace_file_);
+       printf("  for writing. Disabling tracefile output.\n");
+       trace_enable_ = 0;
+     } else {
+       fprintf(trace_fp_, "METRIC TCPTableSize %s.%s %f %d %d\n",
+           trace_prefix_, trace_nodename_, now(), connections_, table_size_);
+       fclose(trace_fp_);
+     }
+   }
+ }
+ 
+ void TcpListenerAgent::expire_connections() {
+   
+   double diff = 0, simtime = now();
+ 
+   for (cmap_it it = cmap_.begin(); it != cmap_.end(); it++) {
+     if ((*it).second->est == false) {
+       diff = simtime - (*it).second->connect_time;
+       if (diff >= entry_expire_) {
+         if (debug_ > 1) {
+           printf("%f: TcpListenerAgent(%s): expired connection, deleting...\n",
+               now(), agent_name);
+         }
+         del_connection((*it).first.first, (*it).first.second);
+       }
+     }
+   }
+ }
+ 
+ bool TcpListenerAgent::get_connection(ipaddr_t src_ip, ipportaddr_t sport) {
+   
+   cmap_it it = cmap_.find(cmap_kt(src_ip, sport));
+   
+   if (it != cmap_.end()) {
+     return true;
+   }
+   return false;
+ }
+ 
+ void TcpListenerAgent::del_connection(ipaddr_t src_ip, ipportaddr_t sport) {
+   
+   cmap_it it = cmap_.find(cmap_kt(src_ip, sport));
+   
+   delete (*it).second;
+   cmap_.erase(cmap_kt(src_ip, sport));
+   connections_--;
+   if (debug_ > 1) {
+     printf("%f: TcpListenerAgent(%s): del_connection():\n",
+         now(), agent_name);
+     printf("  srcip %08x sport %d deleted\n", src_ip, sport);
+   }
+   if (debug_ > 2) {
+     printf("%f: TcpListenerAgent(%s): cmap_ list:\n", now(), agent_name);
+     for (cmap_it it = cmap_.begin(); it != cmap_.end(); it++)
+       printf("  srcip %08x sport %d ct %f\n", ((*it).first).first,
+           ((*it).first).second, ((*it).second)->connect_time);
+   }
+   // Trace this data to out file
+   if (trace_enable_ > 0) {
+     trace_pktcount_ = 0;
+     if ((trace_fp_ = fopen(trace_file_, "a")) == NULL) {
+       printf("%f: TcpListenerAgent(%s): cannot open tracefile (%s)\n",
+           now(), agent_name, trace_file_);
+       printf("  for writing. Disabling tracefile output.\n");
+       trace_enable_ = 0;
+     } else {
+       fprintf(trace_fp_, "METRIC TCPTableSize %s.%s %f %d %d\n",
+           trace_prefix_, trace_nodename_, now(), connections_, table_size_);
+       fclose(trace_fp_);
+     }
+   }
+ }
+ 
+ bool TcpListenerAgent::add_agentinfo(ipaddr_t src_ip, ipportaddr_t sport, 
+     Agent *agent_add) {
+   
+   cmap_it it = cmap_.find(cmap_kt(src_ip, sport));
+ 
+   if (it != cmap_.end()) {
+     ((*it).second)->pAgent = agent_add;
+     ((*it).second)->est = true; // Also flip the connection to established
+     if (debug_ > 1) {
+       printf("%f: TcpListenerAgent(%s): add_agentinfo() added %s\n", 
+           now(), agent_name, ((*it).second)->pAgent->name());
+     }
+     return true;
+   }
+   return false;
+ }
+ 
+ Agent *TcpListenerAgent::get_agentinfo(ipaddr_t src_ip, ipportaddr_t sport) {
+   
+   cmap_it it = cmap_.find(cmap_kt(src_ip, sport));
+ 
+   if (it != cmap_.end()) {
+     return ((*it).second)->pAgent;
+   }
+   return NULL;
+ }
+ 
+ void TcpListenerAgent::inherit_attributes(TcpListenerAgent *a) {
+ 
+   reset();
+   // First get TcpAgent attributes
+   wnd_ = a->wnd_; 
+   wnd_init_ = a->wnd_init_;
+   wnd_init_option_ = a->wnd_init_option_;
+   wnd_option_ = a->wnd_option_;
+   wnd_const_ = a->wnd_const_;
+   wnd_th_ = a->wnd_th_;
+   delay_growth_ = a->delay_growth_;
+   overhead_ = a->overhead_;
+   tcp_tick_ = a->tcp_tick_;
+   ecn_ = a->ecn_;
+   old_ecn_ = a->old_ecn_;
+   eln_ = a->eln_;
+   eln_rxmit_thresh_ = a->eln_rxmit_thresh_;
+   size_ = a->size_;
+   tcpip_base_hdr_size_ = a->tcpip_base_hdr_size_;
+   ts_option_size_ = a->ts_option_size_;
+   bug_fix_ = a->bug_fix_;
+   less_careful_ = a->less_careful_;
+   ts_option_ = a->ts_option_;
+   slow_start_restart_ = a->slow_start_restart_;
+   restart_bugfix_ = a->restart_bugfix_;
+   maxburst_ = a->maxburst_;
+   maxcwnd_ = a->maxcwnd_;
+   numdupacks_ = a->numdupacks_;
+   numdupacksFrac_ = a->numdupacksFrac_;
+   maxrto_ = a->maxrto_;
+   minrto_ = a->minrto_;
+   srtt_init_ = a->srtt_init_;
+   rttvar_init_ = a->rttvar_init_;
+   rtxcur_init_ = a->rtxcur_init_;
+   T_SRTT_BITS = a->T_SRTT_BITS;
+   T_RTTVAR_BITS = a->T_RTTVAR_BITS;
+   rttvar_exp_ = a->rttvar_exp_;
+   awnd_ = a->awnd_;
+   decrease_num_ = a->decrease_num_;
+   increase_num_ = a->increase_num_;
+   k_parameter_ = a->k_parameter_;
+   l_parameter_ = a->l_parameter_;
+   trace_all_oneline_ = a->trace_all_oneline_;
+   nam_tracevar_ = a->nam_tracevar_;
+   QOption_ = a->QOption_;
+   EnblRTTCtr_ = a->EnblRTTCtr_;
+   control_increase_ = a->control_increase_;
+   noFastRetrans_ = a->noFastRetrans_;
+   precision_reduce_ = a->precision_reduce_;
+   oldCode_ = a->oldCode_;
+   useHeaders_ = a->useHeaders_;
+   low_window_ = a->low_window_;
+   high_window_ = a->high_window_;
+   high_p_ = a->high_p_;
+   high_decrease_ = a->high_decrease_;
+   max_ssthresh_ = a->max_ssthresh_;
+   cwnd_frac_ = a->cwnd_frac_;
+   timerfix_ = a->timerfix_;
+   rfc2988_ = a->rfc2988_;
+   singledup_ = a->singledup_;
+   rate_request_ = a->rate_request_;
+   qs_enabled_ = a->qs_enabled_;
+   // Now get FullTcpAgent attributes
+   segs_per_ack_ = a->segs_per_ack_;
+   maxseg_ = a->maxseg_;
+   tcprexmtthresh_ = a->tcprexmtthresh_;
+   iss_ = a->iss_;
+   spa_thresh_ = a->spa_thresh_;
+   nodelay_ = a->nodelay_;
+   data_on_syn_ = a->data_on_syn_;
+   dupseg_fix_ = a->dupseg_fix_;
+   dupack_reset_ = a->dupack_reset_;
+   signal_on_empty_ = a->signal_on_empty_;
+   delack_interval_ = a->delack_interval_;
+   ts_option_size_ = a->ts_option_size_;
+   reno_fastrecov_ = a->reno_fastrecov_;
+   pipectrl_ = a->pipectrl_;
+   open_cwnd_on_pack_ = a->open_cwnd_on_pack_;
+   halfclose_ = a->halfclose_;
+   nopredict_ = a->nopredict_;
+ }
+ 
+ void TcpListenerAgent::promote() {
+   
+   close_on_empty_ = 0; // force close_on_empty false
+   reset();
+   last_send_time_ = -1.0; 
+   last_ack_sent_ += 2;
+   rcv_nxt_ += 2;
+   pipe_ += 1;
+   rtxbytes_ += 1;
+   flags_ = 0;
+   irs_ += 1;
+   iss_ = 0;
+   t_seqno_ = iss_ + 1;
+   highest_ack_ = iss_;
+   maxseq_ += 2;
+   curseq_ = maxseq_ - 1;
+   recent_ = 0;
+   recent_age_ = 0;
+   nackpack_ = 1;
+   type_ = (packet_t)5;
+   last_state_ = 4;
+   state_ = 4;
+   cwnd_ = 1;
+ }
+ 
+ void TcpListenerAgent::set_src(ipaddr_t ip, ipportaddr_t port) {
+   my_ipaddr_ = ip;
+   my_port_ = port;
+ }
+ 
+ void TcpListenerAgent::recv(Packet *pkt, Handler*) {
+   
+   hdr_tcp *tcph = hdr_tcp::access(pkt);
+   hdr_cmn *th = hdr_cmn::access(pkt);
+   hdr_flags *fh = hdr_flags::access(pkt);
+   hdr_rti *rti = hdr_rti::access(pkt);
+ 
+   int datalen = th->size() - tcph->hlen();
+   int tiflags = tcph->flags();
+   Tcl &tcl = Tcl::instance();
+ 
+   ipaddr_t src_ip = rti->ipsrc();
+   ipaddr_t dst_ip = rti->ipdst();
+   ipportaddr_t sport = rti->ipsrcport();
+   ipportaddr_t dport = rti->ipdstport();
+ 
+   // Store Node info for future reference
+   if (!pNode) {
+     pNode = (Node *)GetLocalIP(dst_ip);
+     if (!pNode) {
+       tcl.evalf("%s set node_", name());
+       strcpy(node_name, tcl.result());
+       pNode = (Node *)TclObject::lookup(node_name);
+       if (!pNode) {
+         printf("%f: TcpListenerAgent(%s): FATAL: Node lookup failed!\n",
+             now(), name());
+         exit(1);
+       }
+     } else {
+       strcpy(node_name, pNode->name());
+     }
+     strcpy(agent_name, name());
+     if (trace_enable_ > 0) {
+       tcl.evalf("%s set id_", node_name);
+       trace_nodename_ = strdup(tcl.result());
+     }
+   }
+   
+   if (debug_ > 1) {
+     printf("%f: TcpListenerAgent(%s): incoming %s packet:\n", now(), 
+         agent_name, flagstr(tiflags));
+     printf("  srcip %08x sport %d dstip %08x dport %d\n", src_ip, sport,
+         dst_ip, dport);
+     printf("  ts %d conn %d tiflags %d datalen %d seqno %d ackno %d\n",
+         table_size_, connections_, tiflags, datalen, tcph->seqno(),
+         tcph->ackno());
+   }
+   // Increment trace packet counter
+   if (trace_enable_ > 0) {
+     trace_pktcount_++;
+   }
+   
+   // Incoming SYN Packet (passive open)
+   if (tiflags & TH_SYN) {
+     // Trace this data to out file
+     if (trace_enable_ > 1 && trace_pktcount_ % trace_interval_ == 0) {
+       trace_pktcount_ = 0;
+       if ((trace_fp_ = fopen(trace_file_, "a")) == NULL) {
+         printf("%f: TcpListenerAgent(%s): cannot open tracefile (%s)\n",
+             now(), agent_name, trace_file_);
+         printf("  for writing. Disabling tracefile output.\n");
+         trace_enable_ = 0;
+       } else {
+         fprintf(trace_fp_, "PACKET * %s.%s %f %s 1.0\n", trace_prefix_,
+             trace_nodename_, now(), COLOR_SYN);
+         fclose(trace_fp_);
+       }
+     }
+ #ifdef HAVE_FILTER
+     if (filter_enable_ == 1) {
+       if ((double)connections_ / (double)table_size_ >= filter_trigger_) {
+         if (max_synack_retries_ == 0) {
+           expire_connections();
+         }
+         if ((double)connections_ / (double)table_size_ >= filter_trigger_) {
+           if (filter_on_ == false) {
+             filter_on_ = true;
+             SendOOBFilter(RTIFilterStart);
+             if (debug_ > 0) {
+               printf("%f: TcpListenerAgent(%s): Filter Triggered! (%.1f%)\n",
+                  now(), agent_name, filter_trigger_ * 100);
+             }
+           }
+         } else if (((double)connections_ / (double)table_size_ <= 
+               filter_release_) && (filter_on_ == true)) {
+           filter_on_ = false;
+           SendOOBFilter(RTIFilterStop);
+           if (debug_ > 0) {
+             printf("%f: TcpListenerAgent(%s): Filter Released! (%.1f%)\n",
+                now(), agent_name, filter_release_ * 100);
+           }
+         } // release else
+       } // trigger check
+     } // filter_enable_
+ #endif
+     // Check TCP Connection Table first
+     if (connections_ >= table_size_) {
+       if (max_synack_retries_ == 0) {
+         expire_connections();
+       }
+       if (connections_ >= table_size_) {
+         if (debug_ > 0) {
+           printf("%f: TcpListenerAgent(%s): TCP connection table full (%d)\n",
+              now(), agent_name, table_size_);
+         }
+       } else {
+         goto cont;
+       }
+     } else {
+ cont:
+       if (debug_ > 1) {
+         printf("%f: TcpListenerAgent(%s): SYN packet recv'd\n", now(), 
+             agent_name);
+       }
+       // Allocate connection information
+       if (get_connection(src_ip, sport) == false) {
+         add_connection(src_ip, sport);
+       }
+       // Send SYN+ACK packet back to src_ip
+       dooptions(pkt);
+       irs_ = tcph->seqno();
+       t_seqno_ = iss_;
+       rcv_nxt_ = rcvseqinit(irs_, datalen);
+       flags_ |= TF_ACKNOW;
+       tcph->seqno()++;
+       cwnd_ = initial_window();
+       newstate(TCPS_SYN_RECEIVED);
+       // Reconnect back to remote sources
+       NsObject *pObj = GetLocalIP(src_ip);
+       Agent *tmpAgent = GetIPRoute(src_ip, dst_ip);
+       if (pObj == NULL || tmpAgent != NULL) {
+         tcl.evalf("%s set-dst-ipaddr %d; %s set-dst-port %d; [[Simulator instance] set scheduler_] iproute-connect %s %d %d", agent_name, src_ip, agent_name, sport, agent_name, src_ip, sport);
+         if (debug_ > 1) {
+           printf("%f: TcpListenerAgent(%s): remote iproute-connect (%08x:%d)\n",
+               now(), agent_name, src_ip, sport);
+         }
+       } else {
+         char tmp[255];
+         tcl.evalf("%s findport %d", pObj->name(), sport);
+         strcpy(tmp, tcl.result());
+         if (strcmp(tmp, "") == 0) {
+           tcl.evalf("%s get-droptarget", pObj->name());
+           strcpy(tmp, tcl.result());
+         }
+         tcl.evalf("[Simulator instance] connect %s %s", agent_name, tmp);
+         if (debug_ > 1) {
+           printf("%f: TcpListenerAgent(%s): local connect (%08x:%d)\n",
+               now(), agent_name, src_ip, sport);
+         }
+       }
+       dst_ipaddr_ = src_ip;
+       dst_ipport_ = sport;
+       send_much(1, REASON_NORMAL, maxburst_);
+       // Add timeout to map
+       if (max_synack_retries_ > 0) {
+         add_timeout(rtt_timeout(), src_ip, sport, 0);
+         schedule_timeout();
+       }
+       // Trace this data to out file
+       if (trace_enable_ > 1 && trace_pktcount_ % trace_interval_ == 0) {
+         trace_pktcount_ = 0;
+         if ((trace_fp_ = fopen(trace_file_, "a")) == NULL) {
+           printf("%f: TcpListenerAgent(%s): cannot open tracefile (%s)\n",
+               now(), agent_name, trace_file_);
+           printf("  for writing. Disabling tracefile output.\n");
+           trace_enable_ = 0;
+         } else {
+           fprintf(trace_fp_, "PACKET %s.%s * %f %s\n", trace_prefix_,
+               trace_nodename_, now(), COLOR_SYNACK);
+           fclose(trace_fp_);
+         }
+       }
+     }
+     Packet::free(pkt);
+   } else if (tiflags == 16 || ((tiflags & TH_ACK) && (tiflags & TH_PUSH))) {
+     // ACK for our SYN+ACK only if an existing connection doesn't exist yet
+     if (get_connection(src_ip, sport) == true) {
+       Agent *pAgent = get_agentinfo(src_ip, sport);
+       if (!pAgent) {
+         char ft_an[255];
+         bool no_attach = false;
+         // No existing active connection, create new
+         if (prebinding_ != 0 && (fulltcp_use_ < fulltcp_num_)) {
+           pAgent = fulltcp_[fulltcp_use_];
+           fulltcp_use_++;
+           no_attach = true;
+         } else {
+           tcl.evalf("new Agent/TCP/FullTcp");
+           pAgent = (Agent *)TclObject::lookup(tcl.result());
+           // Set the the source ip for the new agent as my ip address
+           ((TcpListenerAgent *)pAgent)->set_src(dst_ip, dport);
+         }
+         if (!pAgent) {
+           printf("%f: TcpListenerAgent(%s): FATAL: Can't create FullTcpAgent\n",
+               now(), agent_name);
+           exit(1);
+         }
+         strcpy(ft_an, pAgent->name());
+         // Attach agent to node and connect to source ip
+         if (no_attach == false) {
+           tcl.evalf("[Simulator instance] attach-agent %s %s", node_name,
+               ft_an);
+         }
+         NsObject *pObj = GetLocalIP(src_ip);
+         Agent *tmpAgent = GetIPRoute(src_ip, dst_ip);
+         if (pObj != NULL && tmpAgent == NULL) {
+           char tmp[255];
+           tcl.evalf("%s findport %d", pObj->name(), sport);
+           strcpy(tmp, tcl.result());
+           if (strcmp(tmp, "") == 0) {
+             // This should never happen!... but just in case
+             tcl.evalf("%s get-droptarget", pObj->name());
+             strcpy(tmp, tcl.result());
+           }
+           tcl.evalf("[Simulator instance] connect %s %s", ft_an, tmp);
+         } else {
+           tcl.evalf("%s set-dst-ipaddr %d; %s set-dst-port %d; [[Simulator instance] set scheduler_] iproute-connect %s %d %d", ft_an, src_ip, ft_an, sport, ft_an, src_ip, sport);
+         }
+         // Attach a custom application if available
+         if (app_agent_ != NULL) {
+           if (app_reuse_ != 0) {
+             if (app_pApp_ == NULL) {
+               if (strcmp(app_params_, "0") != 0) {
+                 tcl.evalf("new %s %s", app_agent_, app_params_);
+               } else {
+                 tcl.evalf("new %s", app_agent_);
+               }
+               app_pApp_ = (NsObject *)TclObject::lookup(tcl.result());
+               // Perform application callback
+               if (strcmp(app_callback_, "0") != 0) {
+                 tcl.evalf("%s %s %s", app_pApp_->name(), app_callback_, ft_an);
+               }
+               if (app_recv_ != 0) {
+                 tcl.evalf("%s enable-recv", app_pApp_->name());
+               }
+             }
+             tcl.evalf("%s attach-agent %s", app_pApp_->name(), ft_an);
+           } else {
+             if (strcmp(app_params_, "0") != 0) {
+               tcl.evalf("new %s %s", app_agent_, app_params_);
+             } else {
+               tcl.evalf("new %s", app_agent_);
+             }
+             NsObject *pApp = (NsObject *)TclObject::lookup(tcl.result());
+             // Perform application callback
+             if (strcmp(app_callback_, "0") != 0) {
+               tcl.evalf("%s %s %s", pApp->name(), app_callback_, ft_an);
+             }
+             if (app_recv_ != 0) {
+               tcl.evalf("%s enable-recv", pApp->name());
+             }
+             tcl.evalf("%s attach-agent %s", pApp->name(), ft_an);
+           }
+         }
+         if (debug_ > 1) {
+           printf("%f: TcpListenerAgent(%s): FullTcpAgent %s attached to %s\n",
+               now(), agent_name, ft_an, node_name);
+           printf("  rconnected to %08x on port %d\n", src_ip, sport);
+         }
+         // Promote FullTcpAgent to TCPS_ESTABLISHED
+         ((TcpListenerAgent *)pAgent)->inherit_attributes(this);
+         ((TcpListenerAgent *)pAgent)->promote();
+         if (add_agentinfo(src_ip, sport, pAgent) == false) {
+           printf("%f: TcpListenerAgent(%s): FATAL: pAgent add to cmap failed\n",
+               now(), agent_name);
+           exit(1);
+         }
+         Packet::free(pkt);
+         if (debug_ > 1) {
+           printf("%f: TcpListenerAgent(%s): 3-way handshake complete ",
+               now(), agent_name);
+           printf("with %08x\n", src_ip);
+         }
+         // Modify timeout entry that connection was established
+         if (max_synack_retries_ > 0) {
+           est_timeout(src_ip, sport);
+         }
+         // Trace this data to out file
+         if (trace_enable_ > 1 && trace_pktcount_ % trace_interval_ == 0) {
+           trace_pktcount_ = 0;
+           if ((trace_fp_ = fopen(trace_file_, "a")) == NULL) {
+             printf("%f: TcpListenerAgent(%s): cannot open tracefile (%s)\n",
+                 now(), agent_name, trace_file_);
+             printf("  for writing. Disabling tracefile output.\n");
+             trace_enable_ = 0;
+           } else {
+             fprintf(trace_fp_, "PACKET * %s.%s %f %s\n", trace_prefix_,
+                 trace_nodename_, now(), COLOR_ACK);
+             fclose(trace_fp_);
+           }
+         }
+       } else {
+         // forward packet to FullTcpAgent
+         goto handoff;
+       }
+     }
+   } else {
+ handoff:
+     // forward packet to FullTcpAgent
+     Agent *pAgent = get_agentinfo(src_ip, sport);
+     if (!pAgent) {
+       printf("%f: TcpListenerAgent(%s): FATAL: get_agentinfo() failed on %s packet\n", now(), agent_name, flagstr(tiflags));
+       printf("  srcip %08x sport %d dstip %08x dport %d\n", src_ip, sport,
+           dst_ip, dport);
+       printf("  ts %d conn %d tiflags %d datalen %d seqno %d ackno %d\n",
+           table_size_, connections_, tiflags, datalen, tcph->seqno(),
+           tcph->ackno());
+       exit(1);
+     }
+     if (debug_ > 1) {
+       printf("%f: TcpListenerAgent(%s): packet handoff to ",
+           now(), agent_name);
+       printf("FullTcpAgent::recv()\n");
+     }
+     // Trace this data to out file
+     if (trace_enable_ > 2 && trace_pktcount_ % trace_interval_ == 0) {
+       trace_pktcount_ = 0;
+       if ((trace_fp_ = fopen(trace_file_, "a")) == NULL) {
+         printf("%f: TcpListenerAgent(%s): cannot open tracefile (%s)\n",
+             now(), agent_name, trace_file_);
+         printf("  for writing. Disabling tracefile output.\n");
+         trace_enable_ = 0;
+       } else {
+         fprintf(trace_fp_, "PACKET * %s.%s %f %s\n", trace_prefix_,
+             trace_nodename_, now(), COLOR_DATA);
+         fclose(trace_fp_);
+       }
+     }
+     pAgent->recv(pkt, (Handler*)NULL);
+     // Check to see if the connection has been closed
+     if (((TcpListenerAgent *)pAgent)->get_state() == TCPS_CLOSED) {
+       del_connection(src_ip, sport);
+       if (debug_ > 1) {
+         printf("%f: TcpListenerAgent(%s): TCP connection closed with %08x\n",
+             now(), agent_name, src_ip);
+         printf("  ts %d conn %d\n", table_size_, connections_);
+       }
+     } else if (trace_enable_ > 2 && trace_pktcount_ % trace_interval_ == 0) {
+       trace_pktcount_ = 0;
+       if ((trace_fp_ = fopen(trace_file_, "a")) == NULL) {
+         printf("%f: TcpListenerAgent(%s): cannot open tracefile (%s)\n",
+             now(), agent_name, trace_file_);
+         printf("  for writing. Disabling tracefile output.\n");
+         trace_enable_ = 0;
+       } else {
+         fprintf(trace_fp_, "PACKET %s.%s * %f %s\n", trace_prefix_,
+             trace_nodename_, now(), COLOR_DATA);
+         fclose(trace_fp_);
+       }
+     }
+   }
+   reset_state();
+ }
+ 
+ void TcpListenerAgent::add_timeout(double to, ipaddr_t src_ip, 
+     ipportaddr_t sport, int retries) {
+ 
+   timeout_info_t *to_info = new timeout_info_t;
+   to_info->src_ip = src_ip;
+   to_info->sport = sport;
+   to_info->retries = retries;
+   to_info->est = false;
+ 
+   tomap_.insert(tomap_pt(now() + to, to_info));
+ 
+   if (debug_ > 2) {
+     printf("%f: TcpListenerAgent(%s): tomap_ list:\n", now(), agent_name);
+     for (tomap_it it = tomap_.begin(); it != tomap_.end(); it++)
+       printf("  to %f srcip %08x sport %d\n",
+           (*it).first, ((*it).second)->src_ip, ((*it).second)->sport);
+   }
+ }
+ 
+ void TcpListenerAgent::schedule_timeout() {
+   
+   double simtime = now();
+   if (!tomap_.empty()) {
+     tomap_it it;
+     // First check to see if we really need to reschedule
+     it = tomap_.begin();
+     if (current_to_ > (*it).first || current_to_ == 0.0) {
+       // Cancel any outstanding timeouts
+       ltimer_.force_cancel();
+       for (it = tomap_.begin(); it != tomap_.upper_bound(simtime); it++) {
+         // If the connection is established or timeout is in the past, remove
+         if (((*it).second->est == true) || ((*it).first < simtime)) {
+           // Delete timeout
+           delete (*it).second;
+           tomap_.erase(it);
+           if (tomap_.empty())
+             return;
+         }
+       }
+       it = tomap_.begin(); // re-get first entry
+       if (debug_ > 1) {
+         printf("%f: TcpListenerAgent(%s): scheduling timeout at %f,",
+             simtime, agent_name, (*it).first);
+         printf(" retries %d\n", ((*it).second)->retries);
+       }
+       ltimer_.resched((*it).first - simtime); // resched wants offset from now
+       current_to_ = (*it).first;
+     } // if current_to_ > (*it).first
+   } // if !tomap_.empty()
+ }
+ 
+ void TcpListenerAgent::est_timeout(ipaddr_t src_ip, ipportaddr_t sport) {
+ 
+   // Now modify the tomap_ est bool
+   for (tomap_it it = tomap_.begin(); it != tomap_.end(); it++) {
+     if ( ((*it).second)->src_ip == src_ip &&
+         ((*it).second)->sport == sport ) {
+       ((*it).second)->est = true;
+       if (debug_ > 1) {
+         printf("%f: TcpListenerAgent(%s): tomap est flipped\n", now(),
+             agent_name);
+         printf("  to %f srcip %08x sport %d est %d\n", (*it).first,
+             ((*it).second)->src_ip, ((*it).second)->sport, ((*it).second)->est);
+       }
+       break;
+     }
+   }
+ }
+ 
+ void TcpListenerAgent::timeout() {
+ 
+   current_to_ = 0.0; // timeout in progress, reset current timeout
+   // Find map entry at now()
+   tomap_it it;
+   for (it = tomap_.find(now()); it != tomap_.end(); it = tomap_.find(now())) {
+     if ( ((*it).second->est == true) || ((*it).first < now()) ) {
+       // Connection already established, remove from tomap
+       if (debug_ > 1) {
+         printf("%f: TcpListenerAgent(%s): active connection exists (%08x:%d)\n",
+             now(), agent_name, (*it).second->src_ip, (*it).second->sport);
+       }
+       delete (*it).second;
+       tomap_.erase(it);
+     } else {
+       // Retry SYN+ACK packet if we haven't reached max attempts
+       Tcl &tcl = Tcl::instance();
+       ipaddr_t src_ip = (*it).second->src_ip;
+       ipportaddr_t sport = (*it).second->sport;
+       int retries = (*it).second->retries;
+       retries++; // Increment retry counter
+       // Delete current timeout entry
+       delete (*it).second;
+       tomap_.erase(it);
+       // See if we are over the SYN+ACK retry limit
+       if (retries > max_synack_retries_) {
+         // Maximum SYN+ACK retry limit hit, delete connection info
+         del_connection(src_ip, sport);
+         if (debug_ > 1) {
+           printf("%f: TcpListenerAgent(%s): Max SYN+ACK retries (%d)\n",
+               now(), agent_name, max_synack_retries_);
+           printf("  tomap_ %d srcip %08x sport %d removed\n",
+               tomap_.size(), src_ip, sport);
+         }
+         continue;
+       }
+       // Retransmit another SYN+ACK packet back to src_ip
+       if (debug_ > 1) {
+         printf("%f: TcpListenerAgent(%s): Retrying SYN+ACK to %08x %d\n",
+             now(), agent_name, src_ip, sport);
+       }
+       // Construct and send packet
+       reset_state();
+       t_seqno_ = iss_;
+       rcv_nxt_ = rcvseqinit(irs_, 0);
+       flags_ |= TF_ACKNOW;
+       ++nrexmit_;
+       recover_ = maxseq_;
+       cwnd_ = initial_window();
+       slowdown(CLOSE_SSTHRESH_HALF|CLOSE_CWND_RESTART);
+       reset_rtx_timer(1);
+       t_seqno_ = (highest_ack_ < 0) ? iss_ : int(highest_ack_);
+       fastrecov_ = FALSE;
+       dupacks_ = 0;
+       newstate(TCPS_SYN_RECEIVED);
+       // Reconnect back to the remote sources
+       NsObject *pObj = GetLocalIP(src_ip);
+       Agent *tmpAgent = GetIPRoute(src_ip, my_ipaddr_);
+       if (pObj == NULL || tmpAgent != NULL) {
+         tcl.evalf("%s set-dst-ipaddr %d; %s set-dst-port %d; [[Simulator instance] set scheduler_] iproute-connect %s %d %d", agent_name, src_ip, agent_name, sport, agent_name, src_ip, sport);
+         if (debug_ > 1) {
+           printf("%f: TcpListenerAgent(%s): remote iproute-connect (%08x:%d)\n",
+               now(), agent_name, src_ip, sport);
+         }
+       } else {
+         char tmp[255];
+         tcl.evalf("%s findport %d", pObj->name(), sport);
+         strcpy(tmp, tcl.result());
+         if (strcmp(tmp, "") == 0) {
+           tcl.evalf("%s get-droptarget", pObj->name());
+           strcpy(tmp, tcl.result());
+         }
+         tcl.evalf("[Simulator instance] connect %s %s", agent_name, tmp);
+         if (debug_ > 1) {
+           printf("%f: TcpListenerAgent(%s): local connect (%08x:%d)\n",
+               now(), agent_name, src_ip, sport);
+         }
+       }
+       // Set IP info since we are coming from a timeout
+       dst_ipaddr_ = src_ip;
+       dst_ipport_ = sport;
+       send_much(1, PF_TIMEOUT, maxburst_);
+       // Add new timeout entry and schedule
+       for (int i = 0; i < retries; i++)
+         rtt_backoff();
+       add_timeout(rtt_timeout(), src_ip, sport, retries);
+       // Trace this data to out file
+       if (trace_enable_ > 0) {
+         trace_pktcount_++;
+       }
+       if (trace_enable_ > 1 && trace_pktcount_ % trace_interval_ == 0) {
+         trace_pktcount_ = 0;
+         if ((trace_fp_ = fopen(trace_file_, "a")) == NULL) {
+           printf("%f: TcpListenerAgent(%s): cannot open tracefile (%s)\n",
+               now(), agent_name, trace_file_);
+           printf("  for writing. Disabling tracefile output.\n");
+           trace_enable_ = 0;
+         } else {
+           fprintf(trace_fp_, "PACKET %s.%s * %f %s\n", trace_prefix_,
+               trace_nodename_, now(), COLOR_SYNACK);
+           fclose(trace_fp_);
+         }
+       }
+     }
+   }
+   schedule_timeout();
+   reset_state();
+ }
+ 
+ void ListenerTimer::expire(Event*) {
+   a_->timeout();
+ }
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcp/tcp-listener.h pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/tcp-listener.h
*** new_p/ns-allinone-2.27/ns-2.27/tcp/tcp-listener.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/tcp-listener.h	Sat Jan 31 14:51:17 2004
***************
*** 0 ****
--- 1,110 ----
+ /* Tcp Listener Agent :: for dynamic FullTcp connections
+  * 
+  * Alfred Park (park@cc.gatech.edu)
+  * College of Computing, Georgia Institute of Technology
+  * See tcp-listener.cc for revision history
+  *
+  */
+ 
+ #include "tcp-full.h"
+ #include "rti/hdr_rti.h"
+ #include "node.h"
+ #include "trace-colors.h"
+ #include <map>
+ 
+ class TcpListenerAgent;
+ 
+ typedef struct {
+   Agent *pAgent;
+   double connect_time;
+   bool est;
+ } ip_info_t;
+ 
+ typedef pair<ipaddr_t, ipportaddr_t> cmap_kt;
+ typedef map<cmap_kt, ip_info_t*> cmap_t;
+ typedef cmap_t::iterator cmap_it;
+ typedef cmap_t::value_type cmap_pt;
+ 
+ typedef struct {
+   ipaddr_t src_ip;
+   ipportaddr_t sport;
+   int retries;
+   bool est;
+ } timeout_info_t;
+ 
+ typedef multimap<double, timeout_info_t*> tomap_t;
+ typedef tomap_t::iterator tomap_it;
+ typedef tomap_t::value_type tomap_pt;
+ 
+ class ListenerTimer : public TimerHandler {
+   public:
+     ListenerTimer(TcpListenerAgent *a) : TimerHandler() { a_ = a; }
+   protected:
+     virtual void expire(Event *e);
+     TcpListenerAgent *a_;
+ };
+ 
+ class TcpListenerAgent : public FullTcpAgent {
+   public:
+     TcpListenerAgent();
+     ~TcpListenerAgent() { cancel_timers(); rq_.clear(); }
+     virtual void recv(Packet *pkt, Handler*);
+     virtual int command(int argc, const char*const* argv);
+     virtual void timeout();
+    
+   protected:
+     ListenerTimer ltimer_;
+     cmap_t cmap_;
+     tomap_t tomap_;
+     double current_to_;
+     int table_size_;
+     int connections_;
+     int max_synack_retries_;
+     double entry_expire_;
+     Node *pNode;
+     char node_name[255];
+     char agent_name[255];
+     int filter_enable_;
+     double filter_trigger_;
+     double filter_release_;
+     bool filter_on_;
+     char *app_agent_;
+     char *app_params_;
+     char *app_callback_;
+     int app_recv_;
+     int app_reuse_;
+     NsObject *app_pApp_;
+     int prebinding_;
+     Agent **fulltcp_;
+     unsigned int fulltcp_num_;
+     unsigned int fulltcp_len_;
+     unsigned int fulltcp_use_;
+ #ifndef TCP_TRACEFILE_SUPPORT
+     int trace_enable_;
+     unsigned int trace_interval_;
+     unsigned int trace_pktcount_;
+     char *trace_file_;
+     FILE *trace_fp_;
+     char *trace_prefix_;
+     char *trace_nodename_;
+ #endif
+     void expire_connections();
+     void add_timeout(double to, ipaddr_t src_ip, ipportaddr_t sport, 
+         int retries);
+     void schedule_timeout();
+     void est_timeout(ipaddr_t src_ip, ipportaddr_t sport);
+     void add_connection(ipaddr_t src_ip, ipportaddr_t sport);
+     bool get_connection(ipaddr_t src_ip, ipportaddr_t sport);
+     void del_connection(ipaddr_t src_ip, ipportaddr_t sport);
+     bool add_agentinfo(ipaddr_t src_ip, ipportaddr_t sport, Agent *agent_add);
+     Agent *get_agentinfo(ipaddr_t src_ip, ipportaddr_t sport);
+     int get_state() { return state_; }
+     void reset_state();
+     void promote();
+     void set_src(ipaddr_t ip, ipportaddr_t port);
+     void inherit_attributes(TcpListenerAgent *a);
+     virtual void delay_bind_init_all();
+     virtual int delay_bind_dispatch(const char *varName, 
+         const char *localName, TclObject *tracer);
+ };
+ 
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/tcp/trace-colors.h pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/trace-colors.h
*** new_p/ns-allinone-2.27/ns-2.27/tcp/trace-colors.h	Wed Dec 31 19:00:00 1969
--- pdns-ia64/ns-allinone-2.27/ns-2.27/tcp/trace-colors.h	Sat Jan 31 14:51:17 2004
***************
*** 0 ****
--- 1,17 ----
+ /* Tracefile color definitions 
+  *  
+  * Alfred Park (park@cc.gatech.edu)
+  * College of Computing, Georgia Institute of Technology
+  *
+  */
+ 
+ #ifndef _TRACE_COLORS_H_
+ #define _TRACE_COLORS_H_
+ 
+ #define COLOR_DSYN   "0xff0007"
+ #define COLOR_SYN    "0x00ff00"
+ #define COLOR_SYNACK "0xffba00"
+ #define COLOR_ACK    "0x0048ff"
+ #define COLOR_DATA   "0xffffff"
+ 
+ #endif
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/webcache/webserver.cc pdns-ia64/ns-allinone-2.27/ns-2.27/webcache/webserver.cc
*** new_p/ns-allinone-2.27/ns-2.27/webcache/webserver.cc	Wed Jan 28 20:49:40 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/webcache/webserver.cc	Mon Feb  2 18:00:05 2004
***************
*** 54,59 ****
--- 54,86 ----
    //cancel();
  }
  
+ // ALFRED icc/ecc fix
+ WebServer::WebServer() { }
+ 
+ // ALFRED icc/ecc fix
+ void WebServer::init(WebTrafPool *webpool) {
+   web_pool_ = webpool;
+  
+   // clean busy flag
+   busy_ = 0;
+  
+   // Initialize function flag:
+   // 0: there's no server processing delay
+   // 1: server processing delay from FCFS scheduling policy
+   // 2: server processing delay from STF scheduling policy
+   set_mode(0);
+ 
+   // Initialize server processing raste
+   set_rate(1);
+  
+   // initialize the job queue
+   head = tail = NULL;
+   queue_size_ = 0;
+   queue_limit_ = 0;
+ 
+   //cancel();
+ }
+ 
  // Set server processing rate
  void WebServer::set_rate(double s_rate) {
    rate_ = s_rate;
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/webcache/webserver.h pdns-ia64/ns-allinone-2.27/ns-2.27/webcache/webserver.h
*** new_p/ns-allinone-2.27/ns-2.27/webcache/webserver.h	Wed Jan 28 20:49:40 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/webcache/webserver.h	Mon Feb  2 18:00:16 2004
***************
*** 57,62 ****
--- 57,66 ----
   public:
  	WebServer(WebTrafPool*);
  	
+   // ALFRED icc/ecc fix
+   WebServer();
+   void init(WebTrafPool*);
+   
  	// Assign node to server
  	void set_node(Node *);
  	// Return server's node
diff -Ncr new_p/ns-allinone-2.27/ns-2.27/webcache/webtraf.cc pdns-ia64/ns-allinone-2.27/ns-2.27/webcache/webtraf.cc
*** new_p/ns-allinone-2.27/ns-2.27/webcache/webtraf.cc	Wed Jan 28 20:49:40 2004
--- pdns-ia64/ns-allinone-2.27/ns-2.27/webcache/webtraf.cc	Mon Feb  2 18:00:35 2004
***************
*** 412,418 ****
  			nServer_ = atoi(argv[2]);
  			if (server_ != NULL) 
  				delete []server_;
! 			server_ = new WebServer[nServer_](this);
  
  			return (TCL_OK);
  		} else if (strcmp(argv[1], "set-num-client") == 0) {
--- 412,422 ----
  			nServer_ = atoi(argv[2]);
  			if (server_ != NULL) 
  				delete []server_;
!       // ALFRED icc/ecc fix 
!       //server_ = new WebServer[nServer_](this);
!       server_ = new WebServer[nServer_];
!       for (int i = 0; i < nServer_; i++)
!         server_[i].init(this);
  
  			return (TCL_OK);
  		} else if (strcmp(argv[1], "set-num-client") == 0) {
